# Guide: Conflict Resolution

LR parsers, like the one generated by Alpaca, can encounter **conflicts** when the grammar is ambiguous.
A conflict occurs when the parser has multiple valid actions for a given state and lookahead token.

Alpaca provides a declarative DSL to resolve these conflicts at compile-time, ensuring your parser is deterministic and behaves as expected.

## 1. Types of Conflicts

### Shift/Reduce Conflict
Occurs when the parser can either **shift** (move the current token to the stack) or **reduce** (apply a grammar rule to symbols already on the stack).

**Example (Dangling Else):**
```scala
if (cond) if (cond) stmt else stmt
```
Should the `else` belong to the first `if` or the second?

### Reduce/Reduce Conflict
Occurs when the parser has two or more different rules that could be applied to the same symbols on the stack.
This usually indicates a more serious ambiguity in the grammar.

## 2. Resolving Conflicts in Alpaca

Conflicts are resolved by overriding the `resolutions` member in your `Parser` object. This member is a `Set` of `ConflictResolution` rules.

```scala
object MyParser extends Parser:
  // ... rules ...

  override val resolutions = Set(
    // Resolve conflicts here
  )
```

### The `before` and `after` Operators

Alpaca uses `before` and `after` to define precedence:

- **`A after B`**: `A` has **higher precedence** than `B`. `A` will be reduced **later** than `B` (or `B` will be shifted while `A` is waiting).
- **`A before B`**: `A` has **lower precedence** than `B`. `A` will be reduced **earlier** than `B`.

You can use these operators with both **Tokens** (Terminals) and **Productions** (Rules).

#### Operator Precedence Example
```scala
override val resolutions = Set(
  MyLexer.STAR after MyLexer.PLUS,
  MyLexer.SLASH after MyLexer.PLUS
)
```
This tells the parser that `MyLexer.STAR` and `MyLexer.SLASH` have higher precedence than `MyLexer.PLUS`.

#### Associativity Example
To define **left-associativity** (e.g., `1 + 2 + 3` is `(1 + 2) + 3`), a production should be "before" its own recursive tokens.

```scala
  val Expr: Rule[Int] = rule(
    "add" { case (Expr(l), MyLexer.PLUS(_), Expr(r)) => l + r }
  )

  override val resolutions = Set(
    production.add before MyLexer.PLUS
  )
```

## 3. Named Productions

For fine-grained control, you can assign names to specific productions within a rule.
This allows you to reference that exact production in your `resolutions`.

```scala
val Expr: Rule[Int] = rule(
  "mul" { case (Expr(l), MyLexer.STAR(_), Expr(r)) => l * r },
  "div" { case (Expr(l), MyLexer.SLASH(_), Expr(r)) => l / r },
  { case MyLexer.NUM(n) => n.value }
)

override val resolutions = Set(
  production.mul after MyLexer.PLUS,
  production.div after MyLexer.PLUS
)
```

## 4. Understanding Conflict Errors

When Alpaca detects an unresolved conflict, it produces a detailed compile-time error message.

**Example Error:**
```text
Shift "+" vs Reduce Expr -> Expr + Expr
In situation like:
Expr + Expr + ...
Consider marking production Expr -> Expr + Expr to be alwaysBefore or alwaysAfter "+"
```

### How to read it:
1. **The Conflict**: It tells you exactly which actions are clashing (Shift `+` vs Reduce `Expr`).
2. **The Context**: "In situation like..." shows you a sample input sequence that triggers the ambiguity.
3. **The Suggestion**: It suggests which production and token need a resolution rule.

## 5. Debugging with Graphs

If enabled in [Debug Settings](../debug-settings.html), Alpaca can generate internal representations of the parse table and conflict resolutions to help you visualize complex grammars.

## Best Practices

1. **Keep it Minimal**: Only add resolutions for actual conflicts reported by the compiler.
2. **Use Named Productions**: They make your intentions clearer than referencing raw tokens or entire rules.
3. **Think in Terms of Trees**: Remember that "higher precedence" (`after`) means the operation will appear **lower** in the resulting AST (it stays on the stack longer).
