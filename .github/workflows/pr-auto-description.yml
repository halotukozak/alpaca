name: Auto-generate PR Description

on:
  pull_request:
    types: [opened, edited]

permissions:
  pull-requests: write
  contents: read

jobs:
  auto-description:
    runs-on: ubuntu-latest
    # Skip if the PR is from Dependabot or similar bots that provide their own descriptions
    if: github.actor != 'dependabot[bot]' && github.actor != 'github-actions[bot]'
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Generate and update PR description
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const pr = context.payload.pull_request;
            const prNumber = pr.number;
            const currentBody = pr.body || '';
            
            console.log(`Processing PR #${prNumber}: "${pr.title}"`);
            console.log(`Current body length: ${currentBody.length}`);
            
            // Check if the PR already has a meaningful description
            // Skip if body is non-empty and longer than 50 characters
            // (excluding common boilerplate)
            const minimalPhrases = [
              'Thanks for asking me to work on this',
              'Original prompt',
              'COPILOT',
              'WIP',
              '[WIP]'
            ];
            
            // Check if the description is meaningful
            let hasMinimalDescription = currentBody.trim().length < 50;
            
            // Check if it's mostly boilerplate
            if (!hasMinimalDescription) {
              const bodyWithoutBoilerplate = currentBody
                .split('\n')
                .filter(line => !minimalPhrases.some(phrase => line.includes(phrase)))
                .join('\n')
                .trim();
              
              hasMinimalDescription = bodyWithoutBoilerplate.length < 50;
            }
            
            if (!hasMinimalDescription) {
              console.log('PR already has a meaningful description. Skipping auto-generation.');
              return;
            }
            
            console.log('PR has minimal/no description. Generating automatic description...');
            
            // Fetch PR details including commits and files
            const { data: commits } = await github.rest.pulls.listCommits({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            
            const { data: files } = await github.rest.pulls.listFiles({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            });
            
            // Analyze commits
            const commitMessages = commits.map(c => c.commit.message.split('\n')[0]);
            const uniqueCommitMessages = [...new Set(commitMessages)];
            
            // Analyze files and categorize them
            // Note: These patterns are specific to this Scala project but can be customized
            // for other project structures and naming conventions
            const filesByType = {
              source: [],
              test: [],
              docs: [],
              config: [],
              other: []
            };
            
            files.forEach(file => {
              const filename = file.filename;
              // Test files: in /test/ dir, contain 'test.', or end with Test/Spec
              if (filename.includes('/test/') || filename.includes('test.') || filename.endsWith('Test.scala') || filename.endsWith('Spec.scala')) {
                filesByType.test.push(filename);
              // Documentation: in docs/ dir or markdown files
              } else if (filename.startsWith('docs/') || filename.endsWith('.md')) {
                filesByType.docs.push(filename);
              // Configuration: build files, workflow files, config files
              } else if (filename.includes('build.') || filename.endsWith('.yml') || filename.endsWith('.yaml') || filename.endsWith('.conf')) {
                filesByType.config.push(filename);
              // Source: Scala or Java files
              } else if (filename.endsWith('.scala') || filename.endsWith('.java')) {
                filesByType.source.push(filename);
              } else {
                filesByType.other.push(filename);
              }
            });
            
            // Calculate statistics
            const stats = {
              additions: files.reduce((sum, f) => sum + f.additions, 0),
              deletions: files.reduce((sum, f) => sum + f.deletions, 0),
              filesChanged: files.length,
            };
            
            // Detect what type of change this is based on keywords
            const allText = (pr.title + ' ' + commitMessages.join(' ')).toLowerCase();
            const changeType = [];
            
            if (allText.match(/\b(fix|bug|error|crash|broken)\b/)) changeType.push('bug fix');
            if (allText.match(/\b(feat|feature|add|new|implement)\b/)) changeType.push('feature');
            if (allText.match(/\b(refactor|clean|reorganize)\b/)) changeType.push('refactoring');
            if (allText.match(/\b(doc|documentation|readme)\b/)) changeType.push('documentation');
            if (allText.match(/\b(test|coverage|spec)\b/)) changeType.push('testing');
            if (allText.match(/\b(perf|performance|optimize)\b/)) changeType.push('performance');
            if (allText.match(/\b(build|ci|workflow)\b/)) changeType.push('build/ci');
            
            // Generate description
            let description = '## Automatic Description\n\n';
            description += `This pull request ${changeType.length > 0 ? 'includes ' + changeType.join(', ') + ' changes' : 'modifies the codebase'}.`;
            description += '\n\n';
            
            // Add summary section
            description += '### Summary\n\n';
            if (uniqueCommitMessages.length === 1) {
              description += `- ${uniqueCommitMessages[0]}\n`;
            } else {
              description += uniqueCommitMessages.slice(0, 5).map(msg => `- ${msg}`).join('\n') + '\n';
              if (uniqueCommitMessages.length > 5) {
                description += `- ... and ${uniqueCommitMessages.length - 5} more commits\n`;
              }
            }
            description += '\n';
            
            // Add changes section
            description += '### Changes\n\n';
            description += `- **${stats.filesChanged}** file${stats.filesChanged !== 1 ? 's' : ''} changed\n`;
            description += `- **${stats.additions}** addition${stats.additions !== 1 ? 's' : ''}\n`;
            description += `- **${stats.deletions}** deletion${stats.deletions !== 1 ? 's' : ''}\n`;
            description += '\n';
            
            // Add affected files section
            description += '### Affected Files\n\n';
            
            if (filesByType.source.length > 0) {
              description += '**Source files:**\n';
              filesByType.source.slice(0, 10).forEach(f => {
                description += `- \`${f}\`\n`;
              });
              if (filesByType.source.length > 10) {
                description += `- ... and ${filesByType.source.length - 10} more source files\n`;
              }
              description += '\n';
            }
            
            if (filesByType.test.length > 0) {
              description += '**Test files:**\n';
              filesByType.test.forEach(f => {
                description += `- \`${f}\`\n`;
              });
              description += '\n';
            }
            
            if (filesByType.docs.length > 0) {
              description += '**Documentation:**\n';
              filesByType.docs.forEach(f => {
                description += `- \`${f}\`\n`;
              });
              description += '\n';
            }
            
            if (filesByType.config.length > 0) {
              description += '**Configuration:**\n';
              filesByType.config.forEach(f => {
                description += `- \`${f}\`\n`;
              });
              description += '\n';
            }
            
            // Preserve any existing content (like Copilot prompt sections)
            let finalBody = description;
            if (currentBody.includes('<!-- START COPILOT')) {
              // Extract Copilot sections - capture until end of string or another HTML comment
              const copilotSections = currentBody.match(/<!-- START COPILOT[\s\S]*?(?=<!--(?! START COPILOT)|$)/g) || [];
              if (copilotSections.length > 0) {
                finalBody += '\n---\n\n' + copilotSections.join('\n\n');
              }
            }
            
            // Update the PR description
            console.log('Updating PR description...');
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              body: finalBody
            });
            
            console.log('âœ… PR description updated successfully!');
