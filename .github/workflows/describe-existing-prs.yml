name: Describe Existing Pull Requests

# This workflow can be manually triggered to generate descriptions for existing pull requests
# using GitHub AI (GPT-4o) or a template fallback.

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (preview descriptions without applying)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'
      limit:
        description: 'Limit the number of PRs to process (to avoid rate limits)'
        required: false
        default: '10'
        type: string

permissions:
  pull-requests: write
  contents: read
  models: read

jobs:
  describe-existing-prs:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Generate descriptions for existing PRs
        uses: actions/github-script@v8
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const dryRun = '${{ inputs.dry_run }}' === 'true';
            const limit = parseInt('${{ inputs.limit }}') || 10;
            
            if (dryRun) {
              console.log('ğŸ” DRY RUN MODE - No descriptions will be updated');
            }
            
            console.log(`Processing up to ${limit} PRs...`);

            // Fetch all pull requests
            const prs = await github.paginate(github.rest.pulls.list, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              per_page: 100
            });
            
            console.log(`Found ${prs.length} pull requests.`);
            
            let processedCount = 0;
            let updatedCount = 0;
            let errorCount = 0;
            
            for (const pr of prs) {
              if (processedCount >= limit) {
                console.log(`Reached limit of ${limit} PRs. Stopping.`);
                break;
              }
              
              const prNumber = pr.number;
              const currentBody = pr.body || '';
              
              console.log(`\n[${processedCount + 1}] Processing PR #${prNumber}: "${pr.title}"`);
              
              // Skip if the PR is from Dependabot or similar bots
              if (pr.user.login === 'dependabot[bot]' || pr.user.login === 'github-actions[bot]') {
                console.log('  Skipping: PR is from a bot.');
                continue;
              }

              // Check if the PR already has a meaningful description
              const minimalPhrases = [
                'Thanks for asking me to work on this',
                'Original prompt',
                'COPILOT',
                'WIP',
                '[WIP]'
              ];
              
              let hasMinimalDescription = currentBody.trim().length < 50;
              
              if (!hasMinimalDescription) {
                const bodyWithoutBoilerplate = currentBody
                  .split('\n')
                  .filter(line => !minimalPhrases.some(phrase => line.includes(phrase)))
                  .join('\n')
                  .trim();
                
                hasMinimalDescription = bodyWithoutBoilerplate.length < 50;
              }
              
              if (!hasMinimalDescription) {
                console.log('  PR already has a meaningful description. Skipping.');
                continue;
              }
              
              processedCount++;
              console.log('  PR has minimal/no description. Generating...');

              try {
                // Fetch PR details
                const { data: commits } = await github.rest.pulls.listCommits({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                });
                
                const { data: files } = await github.rest.pulls.listFiles({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                });
                
                const { data: prDiff } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  mediaType: { format: 'diff' }
                });
                
                const commitMessages = commits.map(c => c.commit.message.split('\n')[0]);
                const uniqueCommitMessages = [...new Set(commitMessages)];
                
                const filesByType = { source: [], test: [], docs: [], config: [], other: [] };
                files.forEach(file => {
                  const filename = file.filename;
                  if (filename.includes('/test/') || filename.includes('test.') || filename.endsWith('Test.scala') || filename.endsWith('Spec.scala')) {
                    filesByType.test.push(filename);
                  } else if (filename.startsWith('docs/') || filename.endsWith('.md')) {
                    filesByType.docs.push(filename);
                  } else if (filename.includes('build.') || filename.endsWith('.yml') || filename.endsWith('.yaml') || filename.endsWith('.conf')) {
                    filesByType.config.push(filename);
                  } else if (filename.endsWith('.scala') || filename.endsWith('.java')) {
                    filesByType.source.push(filename);
                  } else {
                    filesByType.other.push(filename);
                  }
                });
                
                const stats = {
                  additions: files.reduce((sum, f) => sum + f.additions, 0),
                  deletions: files.reduce((sum, f) => sum + f.deletions, 0),
                  filesChanged: files.length,
                };
                
                const aiContext = {
                  title: pr.title,
                  commits: uniqueCommitMessages.slice(0, 5),
                  stats: stats,
                  files: files.slice(0, 20).map(f => ({
                    name: f.filename, additions: f.additions, deletions: f.deletions, changes: f.changes
                  })),
                  diff: typeof prDiff === 'string' ? prDiff.slice(0, 5000) : ''
                };
                
                let description = '';
                let aiGenerated = false;
                
                try {
                  const promptContent = 'Generate a pull request description for the following changes:\n\n' +
                    'Title: ' + aiContext.title + '\n\n' +
                    'Commit Messages:\n' + aiContext.commits.map(m => '- ' + m).join('\n') + '\n\n' +
                    'Files Changed (' + stats.filesChanged + ' total):\n' +
                    aiContext.files.map(f => '- ' + f.name + ' (+' + f.additions + '/-' + f.deletions + ')').join('\n') + '\n\n' +
                    'Statistics:\n- ' + stats.additions + ' additions, ' + stats.deletions + ' deletions\n\n' +
                    'Please generate a clear, professional PR description in markdown format with:\n' +
                    '1. A brief summary (2-3 sentences)\n' +
                    '2. Key changes section\n' +
                    '3. Technical details if relevant\n\n' +
                    'Keep it concise and focus on the what and why.';
                  
                  const response = await fetch('https://models.inference.ai.azure.com/chat/completions', {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json',
                      'Authorization': 'Bearer ' + process.env.GITHUB_TOKEN
                    },
                    body: JSON.stringify({
                      messages: [
                        { role: 'system', content: 'You are a helpful assistant that generates concise, informative pull request descriptions. Focus on what changed and why, using clear markdown formatting.' },
                        { role: 'user', content: promptContent }
                      ],
                      model: 'gpt-4o',
                      temperature: 0.7,
                      max_tokens: 500
                    })
                  });
                  
                  if (response.ok) {
                    const aiResult = await response.json();
                    if (aiResult.choices && aiResult.choices[0] && aiResult.choices[0].message) {
                      description = '## AI-Generated Description\n\n' + aiResult.choices[0].message.content.trim() + '\n\n';
                      aiGenerated = true;
                      console.log('    âœ… AI-powered description generated');
                    }
                  }
                } catch (aiError) {
                  console.log(`    âš ï¸ AI error: ${aiError.message}`);
                }
                
                if (!aiGenerated) {
                  console.log('    Falling back to template-based generation');
                  const allText = (pr.title + ' ' + commitMessages.join(' ')).toLowerCase();
                  const changeType = [];
                  if (allText.match(/\b(fix|bug|error|crash|broken)\b/)) changeType.push('bug fix');
                  if (allText.match(/\b(feat|feature|add|new|implement)\b/)) changeType.push('feature');
                  if (allText.match(/\b(refactor|clean|reorganize)\b/)) changeType.push('refactoring');
                  if (allText.match(/\b(doc|documentation|readme)\b/)) changeType.push('documentation');
                  if (allText.match(/\b(test|coverage|spec)\b/)) changeType.push('testing');
                  if (allText.match(/\b(perf|performance|optimize)\b/)) changeType.push('performance');
                  if (allText.match(/\b(build|ci|workflow)\b/)) changeType.push('build/ci');
                  
                  description = '## Automatic Description\n\n';
                  description += `This pull request ${changeType.length > 0 ? 'includes ' + changeType.join(', ') + ' changes' : 'modifies the codebase'}.\n\n`;
                  description += '### Summary\n\n';
                  description += uniqueCommitMessages.slice(0, 5).map(msg => `- ${msg}`).join('\n') + '\n\n';
                  description += '### Changes\n\n';
                  description += `- **${stats.filesChanged}** files changed\n- **${stats.additions}** additions\n- **${stats.deletions}** deletions\n\n`;
                }

                if (aiGenerated) {
                  description += '\n---\n\n### Statistics\n\n';
                  description += `- **${stats.filesChanged}** files changed\n- **${stats.additions}** additions\n- **${stats.deletions}** deletions\n`;
                }

                let finalBody = description;
                if (currentBody.includes('<!-- START COPILOT')) {
                  const copilotSections = currentBody.match(/<!-- START COPILOT[\s\S]*?(?=<!--(?! START COPILOT)|$)/g) || [];
                  if (copilotSections.length > 0) {
                    finalBody += '\n---\n\n' + copilotSections.join('\n\n');
                  }
                }

                if (!dryRun) {
                  await github.rest.pulls.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber,
                    body: finalBody
                  });
                  console.log('    âœ… PR description updated');
                  updatedCount++;
                } else {
                  console.log('    ğŸ‘ï¸ Would update PR description (dry run)');
                  updatedCount++;
                }

                // Delay to respect rate limits
                await new Promise(resolve => setTimeout(resolve, 2000));
                
              } catch (error) {
                console.log(`    âŒ Error processing PR #${prNumber}: ${error.message}`);
                errorCount++;
              }
            }
            
            console.log(`\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
            console.log(`Summary:`);
            console.log(`  Total PRs processed: ${processedCount}`);
            console.log(`  PRs ${dryRun ? 'that would be' : ''} updated: ${updatedCount}`);
            if (errorCount > 0) console.log(`  Errors: ${errorCount}`);
            console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
