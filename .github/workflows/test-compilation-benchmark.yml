name: Test Compilation Benchmark

on:
  pull_request:
    branches: [ master ]

jobs:
  benchmark:
    name: Compilation Benchmark
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read

    steps:
      - name: Checkout PR Branch
        uses: actions/checkout@v6
        with:
          path: current

      - name: Checkout Base Branch
        uses: actions/checkout@v6
        with:
          ref: ${{ github.base_ref }}
          path: base

      - name: Set up JDK
        uses: actions/setup-java@v5
        with:
          java-version: 21
          distribution: temurin

      - name: Cache Mill dependencies
        uses: actions/cache@v5
        with:
          path: |
            ~/.cache/coursier
            ~/.cache/mill
          key: ${{ runner.os }}-mill-${{ hashFiles('current/build.mill') }}
          restore-keys: |
            ${{ runner.os }}-mill-

      - name: Install Hyperfine
        run: |
          sudo apt-get update
          sudo apt-get install -y hyperfine

      - name: Run Benchmarks
        id: benchmark
        run: |
          set -e
          
          run_bench() {
            local dir=$1
            echo "::group::Benchmarking $dir"
            (
              cd "$dir"
          
              hyperfine --runs 5 --prepare "./mill clean \ ./mill compile" "./mill test.compile" --export-json "../${dir}.json"
            )
            echo "::endgroup::"
          }

          run_bench "base"
          run_bench "current"

      - name: Extract Results
        id: extract
        run: |
          echo "base_mean=$(jq '.results[0].mean' base.json)" >> $GITHUB_OUTPUT
          echo "curr_mean=$(jq '.results[0].mean' current.json)" >> $GITHUB_OUTPUT

      - name: Upsert PR Comment
        uses: actions/github-script@v8
        env:
          BASE_MEAN: ${{ steps.extract.outputs.base_mean }}
          CURR_MEAN: ${{ steps.extract.outputs.curr_mean }}
        with:
          script: |
            const baseMean = parseFloat(process.env.BASE_MEAN);
            const currMean = parseFloat(process.env.CURR_MEAN);
            
            const diff = currMean - baseMean;
            const perc = (diff / baseMean) * 100;
            
            const diffAbs = Math.abs(diff).toFixed(3);
            const percAbs = Math.abs(perc).toFixed(2);
            
            let status = 'faster';
            let emoji = '‚úÖ';
            if (perc > 1) {
              status = 'slower';
              emoji = '‚ö†Ô∏è';
            } else if (Math.abs(perc) <= 1) {
              status = 'unchanged';
              emoji = '‚ÑπÔ∏è';
            }

            const body = [
              '### üìä Test Compilation Benchmark',
              '',
              '| Branch | Average Time |',
              '| :--- | :--- |',
              `| **Base (${context.payload.pull_request.base.ref})** | ${baseMean.toFixed(3)}s |`,
              `| **Current (${context.payload.pull_request.head.ref})** | ${currMean.toFixed(3)}s |`,
              '',
              `**Result:** Current branch is **${diffAbs}s ${status}** (${percAbs}%) ${emoji}`
            ].join('\n');

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const botComment = comments.find(c => c.body.includes('### üìä Test Compilation Benchmark'));

            if (botComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }
