name: Label Existing Issues

# This workflow can be manually triggered to label all existing issues
# that don't have labels or need additional labels

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (preview labels without applying)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

permissions:
  issues: write
  contents: read

jobs:
  label-existing-issues:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Label all existing issues
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const dryRun = '${{ inputs.dry_run }}' === 'true';
            
            if (dryRun) {
              console.log('ğŸ” DRY RUN MODE - No labels will be applied');
            }
            
            // Define label rules based on keywords
            const labelRules = {
              'Parser': ['parser', 'parse', 'parsing', 'shift-reduce', 'lr(1)', 'syntax tree', 'ast', 'production', 'grammar', 'rule'],
              'Lexer': ['lexer', 'lexeme', 'token', 'tokenize', 'regex', 'pattern matching', 'lexical'],
              'bug': ['bug', 'error', 'fail', 'broken', 'issue', 'not work', 'crash', 'exception', 'incorrect'],
              'documentation': ['documentation', 'docs', 'readme', 'guide', 'tutorial', 'example', 'explain'],
              'enhancement': ['feature', 'enhancement', 'improve', 'add', 'support', 'should', 'would be nice', 'could'],
              'testing': ['test', 'coverage', 'unit test', 'integration test', 'spec'],
              'build': ['build', 'compile', 'ci', 'github actions', 'workflow', 'mill', 'sbt'],
              'performance': ['performance', 'slow', 'optimize', 'speed', 'efficient', 'benchmark'],
              'error-handling': ['error message', 'diagnostic', 'verbose', 'warning', 'better error'],
              'API': ['api', 'interface', 'public api', 'user-facing', 'usage'],
              'refactoring': ['refactor', 'clean', 'reorganize', 'restructure', 'code quality']
            };
            
            // Fetch all open issues
            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              per_page: 100
            });
            
            console.log(`Found ${issues.length} open issues`);
            
            let processedCount = 0;
            let labeledCount = 0;
            
            for (const issue of issues) {
              // Skip pull requests
              if (issue.pull_request) {
                continue;
              }
              
              processedCount++;
              
              const title = issue.title.toLowerCase();
              const body = (issue.body || '').toLowerCase();
              const content = title + ' ' + body;
              const existingLabels = issue.labels.map(label => label.name);
              
              // Collect labels to add
              const labelsToAdd = [];
              
              for (const [label, keywords] of Object.entries(labelRules)) {
                for (const keyword of keywords) {
                  if (content.includes(keyword)) {
                    labelsToAdd.push(label);
                    break;
                  }
                }
              }
              
              // Remove duplicates and filter out existing labels
              const uniqueLabels = [...new Set(labelsToAdd)];
              const newLabels = uniqueLabels.filter(label => !existingLabels.includes(label));
              
              if (newLabels.length > 0) {
                console.log(`\nIssue #${issue.number}: "${issue.title}"`);
                console.log(`  Existing labels: ${existingLabels.join(', ') || '(none)'}`);
                console.log(`  Labels to add: ${newLabels.join(', ')}`);
                
                if (!dryRun) {
                  try {
                    await github.rest.issues.addLabels({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      issue_number: issue.number,
                      labels: newLabels
                    });
                    console.log(`  âœ… Successfully added labels`);
                    labeledCount++;
                  } catch (error) {
                    console.log(`  âŒ Error adding labels: ${error.message}`);
                  }
                } else {
                  console.log(`  ğŸ‘ï¸ Would add labels (dry run)`);
                  labeledCount++;
                }
                
                // Add a small delay to avoid rate limiting
                await new Promise(resolve => setTimeout(resolve, 100));
              }
            }
            
            console.log(`\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
            console.log(`Summary:`);
            console.log(`  Total issues processed: ${processedCount}`);
            console.log(`  Issues ${dryRun ? 'that would be' : ''} labeled: ${labeledCount}`);
            console.log(`  Mode: ${dryRun ? 'DRY RUN' : 'LIVE'}`);
            console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
