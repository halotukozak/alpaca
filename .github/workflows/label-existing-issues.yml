name: Label Existing Issues and Pull Requests

# This workflow can be manually triggered to label all existing issues and pull requests
# using GitHub Copilot AI for intelligent label suggestions

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (preview labels without applying)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

permissions:
  issues: write
  pull-requests: write
  contents: read

jobs:
  label-existing-issues:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Label all existing issues and pull requests using AI
        uses: actions/github-script@v8
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const dryRun = '${{ inputs.dry_run }}' === 'true';
            
            if (dryRun) {
              console.log('🔍 DRY RUN MODE - No labels will be applied');
            }
            
            // Available labels and their descriptions
            const availableLabels = {
              'Parser': 'Issues related to parser functionality, syntax analysis, grammar rules, AST generation, shift-reduce conflicts, LR parsing',
              'Lexer': 'Issues related to lexer functionality, tokenization, regex patterns, lexical analysis',
              'bug': 'Something isn\'t working correctly - errors, failures, crashes, exceptions',
              'documentation': 'Improvements or additions to documentation, guides, tutorials, examples',
              'enhancement': 'Feature requests or improvements to existing functionality',
              'testing': 'Issues related to tests, test coverage, or testing infrastructure',
              'build': 'Issues related to the build system, CI/CD, compilation, Mill, SBT',
              'performance': 'Performance optimization issues - slow execution, efficiency improvements',
              'error-handling': 'Issues related to error messages, diagnostics, or warnings',
              'API': 'Issues related to the public API or user-facing interfaces',
              'refactoring': 'Code quality improvements or restructuring without changing functionality'
            };
            
            // Build label descriptions for the prompt
            const labelDescriptions = Object.entries(availableLabels)
              .map(([label, desc]) => `- ${label}: ${desc}`)
              .join('\n');
            
            // Prepare the system prompt
            const systemPrompt = `You are an expert issue triaging assistant for the Alpaca project, a Scala 3 lexer and parser library. Your task is to analyze issues and pull requests and assign appropriate labels from a predefined list.

            Available labels:
            ${labelDescriptions}

            Analyze each item and return ONLY a JSON array of label names that should be applied. Return an empty array if no labels match. Do not include any explanation or additional text.

            Example response format: ["Parser", "bug", "performance"]`;

            // Function to get AI label suggestions
            async function getAILabels(title, body, itemType) {
              const userPrompt = `Please analyze this ${itemType} and suggest appropriate labels:

              Title: ${title}

              Body:
              ${body || '(no description provided)'}

              Return only a JSON array of applicable label names.`;

              try {
                const response = await fetch('https://models.inference.ai.azure.com/chat/completions', {
                  method: 'POST',
                  headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${process.env.GITHUB_TOKEN}`
                  },
                  body: JSON.stringify({
                    messages: [
                      { role: 'system', content: systemPrompt },
                      { role: 'user', content: userPrompt }
                    ],
                    model: 'gpt-4o',
                    temperature: 0.3,
                    max_tokens: 150
                  })
                });

                if (!response.ok) {
                  const errorText = await response.text();
                  console.log(`    ⚠️ API request failed: ${response.status}`);
                  return [];
                }

                const data = await response.json();
                const aiResponse = data.choices[0].message.content.trim();
                
                // Parse the AI response
                let suggestedLabels;
                try {
                  const jsonMatch = aiResponse.match(/\[[\s\S]*\]/);
                  if (jsonMatch) {
                    suggestedLabels = JSON.parse(jsonMatch[0]);
                  } else {
                    suggestedLabels = JSON.parse(aiResponse);
                  }
                } catch (parseError) {
                  console.log(`    ⚠️ Failed to parse AI response`);
                  return [];
                }
                
                // Validate labels
                return suggestedLabels.filter(label => 
                  Object.keys(availableLabels).includes(label)
                );
                
              } catch (error) {
                console.log(`    ⚠️ Error getting AI suggestions: ${error.message}`);
                return [];
              }
            }
            
            // Fetch all issues and pull requests (both open and closed)
            const items = await github.paginate(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              per_page: 100
            });
            
            const issues = items.filter(item => !item.pull_request);
            const prs = items.filter(item => item.pull_request);
            
            console.log(`Found ${issues.length} issues and ${prs.length} pull requests (${items.length} total)`);
            
            let processedCount = 0;
            let labeledCount = 0;
            let errorCount = 0;
            
            for (const item of items) {
              processedCount++;
              
              const itemType = item.pull_request ? 'pull request' : 'issue';
              const title = item.title;
              const body = item.body || '';
              const existingLabels = item.labels.map(label => label.name);
              
              console.log(`\n[${processedCount}/${items.length}] ${itemType.toUpperCase()} #${item.number}: "${title}"`);
              console.log(`  Existing labels: ${existingLabels.join(', ') || '(none)'}`);
              
              // Get AI suggestions
              const suggestedLabels = await getAILabels(title, body, itemType);
              
              if (suggestedLabels.length === 0) {
                console.log(`  No labels suggested`);
                // Add delay to respect rate limits
                await new Promise(resolve => setTimeout(resolve, 1000));
                continue;
              }
              
              // Filter out existing labels
              const newLabels = suggestedLabels.filter(label => !existingLabels.includes(label));
              
              if (newLabels.length === 0) {
                console.log(`  AI suggested: ${suggestedLabels.join(', ')} (already applied)`);
                // Add delay to respect rate limits
                await new Promise(resolve => setTimeout(resolve, 1000));
                continue;
              }
              
              console.log(`  AI suggests adding: ${newLabels.join(', ')}`);
              
              if (!dryRun) {
                try {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: item.number,
                    labels: newLabels
                  });
                  console.log(`  ✅ Successfully added labels`);
                  labeledCount++;
                } catch (error) {
                  console.log(`  ❌ Error adding labels: ${error.message}`);
                  errorCount++;
                }
              } else {
                console.log(`  👁️ Would add labels (dry run)`);
                labeledCount++;
              }
              
              // Add delay to respect rate limits (important for AI API)
              await new Promise(resolve => setTimeout(resolve, 1000));
            }
            
            console.log(`\n━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`);
            console.log(`Summary:`);
            console.log(`  Total items processed: ${processedCount}`);
            console.log(`  Items ${dryRun ? 'that would be' : ''} labeled: ${labeledCount}`);
            if (errorCount > 0) {
              console.log(`  Errors: ${errorCount}`);
            }
            console.log(`  Mode: ${dryRun ? 'DRY RUN' : 'LIVE'}`);
            console.log(`━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━`);
