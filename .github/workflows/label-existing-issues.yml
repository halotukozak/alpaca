name: Label Existing Issues and Pull Requests

# This workflow can be manually triggered to label all existing issues and pull requests
# using GitHub Copilot AI for intelligent label suggestions

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run (preview labels without applying)'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

permissions:
  issues: write
  pull-requests: write
  contents: read
  models: read

jobs:
  label-existing-issues:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v6

      - name: Label all existing issues and pull requests using AI
        uses: actions/github-script@v8
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const dryRun = '${{ inputs.dry_run }}' === 'true';
            
            if (dryRun) {
              console.log('ğŸ” DRY RUN MODE - No labels will be applied');
            }
            
            // Available labels and their descriptions
            const availableLabels = {
              'Parser': 'Issues related to parser functionality, syntax analysis, grammar rules, AST generation, shift-reduce conflicts, LR parsing',
              'Lexer': 'Issues related to lexer functionality, tokenization, regex patterns, lexical analysis',
              'bug': 'Something isn\'t working correctly - errors, failures, crashes, exceptions',
              'documentation': 'Improvements or additions to documentation, guides, tutorials, examples',
              'enhancement': 'Feature requests or improvements to existing functionality',
              'testing': 'Issues related to tests, test coverage, or testing infrastructure',
              'build': 'Issues related to the build system, CI/CD, compilation, Mill, SBT',
              'performance': 'Performance optimization issues - slow execution, efficiency improvements',
              'error-handling': 'Issues related to error messages, diagnostics, or warnings',
              'API': 'Issues related to the public API or user-facing interfaces',
              'refactoring': 'Code quality improvements or restructuring without changing functionality',
              'thesis': 'Issues related to the thesis document, research, bibliography, or thesis-specific content'
            };
            
            // Build label descriptions for the prompt
            const labelDescriptions = Object.entries(availableLabels)
              .map(([label, desc]) => `- ${label}: ${desc}`)
              .join('\n');
            
            // Prepare the system prompt
            const systemPrompt = `You are an expert issue triaging assistant for the Alpaca project, a Scala 3 lexer and parser library. Your task is to analyze issues and pull requests and assign appropriate labels from a predefined list.

            Available labels:
            ${labelDescriptions}

            Analyze each item and return ONLY a JSON array of label names that should be applied. Return an empty array if no labels match. Do not include any explanation or additional text.

            Example response format: ["Parser", "bug", "performance"]`;

            // Function to get AI label suggestions with exponential backoff
            async function getAILabels(title, body, itemType, retries = 3) {
              const userPrompt = `Please analyze this ${itemType} and suggest appropriate labels:

              Title: ${title}

              Body:
              ${body || '(no description provided)'}

              Return only a JSON array of applicable label names.`;

              for (let attempt = 0; attempt <= retries; attempt++) {
                try {
                  const response = await fetch('https://models.inference.ai.azure.com/chat/completions', {
                    method: 'POST',
                    headers: {
                      'Content-Type': 'application/json',
                      'Authorization': `Bearer ${process.env.GITHUB_TOKEN}`
                    },
                    body: JSON.stringify({
                      messages: [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: userPrompt }
                      ],
                      model: 'gpt-4o',
                      temperature: 0.3,
                      max_tokens: 150
                    })
                  });

                  if (!response.ok) {
                    const errorText = await response.text();
                    if (response.status === 429 && attempt < retries) {
                      const backoffDelay = Math.pow(2, attempt) * 2000;
                      console.log(`    âš ï¸ Rate limited (429), retrying in ${backoffDelay}ms... (attempt ${attempt + 1}/${retries})`);
                      await new Promise(resolve => setTimeout(resolve, backoffDelay));
                      continue;
                    }
                    console.log(`    âš ï¸ API request failed: ${response.status}`);
                    return [];
                  }

                  const data = await response.json();
                  const aiResponse = data.choices[0].message.content.trim();
            
                  // Parse the AI response
                  let suggestedLabels;
                  try {
                    const jsonMatch = aiResponse.match(/\[[\s\S]*\]/);
                    if (jsonMatch) {
                      suggestedLabels = JSON.parse(jsonMatch[0]);
                    } else {
                      suggestedLabels = JSON.parse(aiResponse);
                    }
                  } catch (parseError) {
                    console.log(`    âš ï¸ Failed to parse AI response`);
                    return [];
                  }
            
                  // Validate labels
                  return suggestedLabels.filter(label => 
                    Object.keys(availableLabels).includes(label)
                  );
            
                } catch (error) {
                  if (attempt < retries) {
                    const backoffDelay = Math.pow(2, attempt) * 2000;
                    console.log(`    âš ï¸ Error: ${error.message}, retrying in ${backoffDelay}ms... (attempt ${attempt + 1}/${retries})`);
                    await new Promise(resolve => setTimeout(resolve, backoffDelay));
                    continue;
                  }
                  console.log(`    âš ï¸ Error getting AI suggestions: ${error.message}`);
                  return [];
                }
              }
              return [];
            }
            
            // Fetch all issues and pull requests (both open and closed)
            const items = await github.paginate(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'all',
              per_page: 100
            });
            
            const issues = items.filter(item => !item.pull_request);
            const prs = items.filter(item => item.pull_request);
            
            console.log(`Found ${issues.length} issues and ${prs.length} pull requests (${items.length} total)`);
            
            let processedCount = 0;
            let labeledCount = 0;
            let errorCount = 0;
            
            for (const item of items) {
              processedCount++;
            
              const itemType = item.pull_request ? 'pull request' : 'issue';
              const title = item.title;
              const body = item.body || '';
              const existingLabels = item.labels.map(label => label.name);
            
              console.log(`\n[${processedCount}/${items.length}] ${itemType.toUpperCase()} #${item.number}: "${title}"`);
              console.log(`  Existing labels: ${existingLabels.join(', ') || '(none)'}`);
            
              // Get AI suggestions with retry logic
              const suggestedLabels = await getAILabels(title, body, itemType);
            
              if (suggestedLabels.length === 0) {
                console.log(`  No labels suggested`);
                // Add delay to respect rate limits
                await new Promise(resolve => setTimeout(resolve, 2000));
                continue;
              }
            
              // Filter out existing labels
              const newLabels = suggestedLabels.filter(label => !existingLabels.includes(label));
            
              if (newLabels.length === 0) {
                console.log(`  AI suggested: ${suggestedLabels.join(', ')} (already applied)`);
                // Add delay to respect rate limits
                await new Promise(resolve => setTimeout(resolve, 2000));
                continue;
              }
            
              console.log(`  AI suggests adding: ${newLabels.join(', ')}`);
            
              if (!dryRun) {
                try {
                  await github.rest.issues.addLabels({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: item.number,
                    labels: newLabels
                  });
                  console.log(`  âœ… Successfully added labels`);
                  labeledCount++;
                } catch (error) {
                  console.log(`  âŒ Error adding labels: ${error.message}`);
                  errorCount++;
                }
              } else {
                console.log(`  ğŸ‘ï¸ Would add labels (dry run)`);
                labeledCount++;
              }
            
              // Add delay to respect rate limits (important for AI API)
              await new Promise(resolve => setTimeout(resolve, 2000));
            }
            
            console.log(`\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);
            console.log(`Summary:`);
            console.log(`  Total items processed: ${processedCount}`);
            console.log(`  Items ${dryRun ? 'that would be' : ''} labeled: ${labeledCount}`);
            if (errorCount > 0) {
              console.log(`  Errors: ${errorCount}`);
            }
            console.log(`  Mode: ${dryRun ? 'DRY RUN' : 'LIVE'}`);
            console.log(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`);