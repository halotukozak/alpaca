\chapter{Algorytmy analizy składniowej}
\label{ch:parser-algorithmic}

\section{Teoretyczne podstawy działania parserów}
\label{sec:parser-theory}

Parser przekształca strumień tokenów w strukturę składniową (AST), rozstrzygając zgodność wejścia z gramatyką. Klasyczne podejścia bazują na automatach skończonych rozszerzonych o stos (PDA) oraz na algorytmach predykcyjnych lub analizie przesuwająco-redukcyjnej.

\subsection{Gramatyki i typy parserów}
Gramatyka bezkontekstowa (CFG) składa się z nieterminali, terminali (tokenów), symbolu startowego i produkcji. Parsery dzieli się na:
\begin{itemize}
    \item \textbf{LL(k)} (zstępujące, predykcyjne) — konstruują lewostronne wyprowadzenia, wybierając produkcje na podstawie prefiksu wejścia (lookahead). Wymagają gramatyk bez lewostronnej rekurencji i z niekolidującymi zbiorami FIRST/FOLLOW.
    \item \textbf{LR(k)} (wstępujące, shift-reduce) — rekonstruują prawostronne wyprowadzenia wstecz, używając stosu stanów automatu LR. Radzą sobie z większą klasą gramatyk, w tym lewostronnie rekurencyjnych.
\end{itemize}

\subsection{Automat ze stosem}
Parser można modelować jako deterministyczny automat ze stosem (PDA): stan określa pozycję w tablicach parsera, stos przechowuje nieterminale/stan, a wejście dostarcza tokeny. Przejścia to operacje \textit{shift} (przesunięcie tokenu na stos) i zastąpienie prawej strony produkcji nieterminalem i przeskok do nowego stanu (\textit{reduce}).

\subsection{Tabele sterujące}
Parsery tabelowe (LL i LR) działają w stałym czasie na token. Tabela akcji LR mapuje parę (stan, lookahead) na \textit{shift}, \textit{reduce}, \textit{accept} lub \textit{error}; tabela goto określa przejścia po redukcjach. W LL analogiczną rolę pełni tabela predykcji (nieterminal × lookahead → produkcja).

\subsection{Rozstrzyganie konfliktów}
Konflikty \textit{shift/reduce} i \textit{reduce/reduce} pojawiają się, gdy tabela parsera jest niedeterministyczna.
Najczęściej rozwiązuje się je przez zmianę gramatyki lub zwiększenie lookaheadu.

W parserach LL problemy zwykle wynikają z lewostronnej rekurencji i wspólnych prefiksów (konieczna
lewostronna faktoryzacja). W parserach LR konflikty najczęściej biorą się ze zbliżonych prefiksów wielu produkcji
(np.\ \texttt{if--then} vs.\ \texttt{if--then--else}) oraz z niejednoznaczności w wyrażeniach
arytmetycznych.

\section{Wybór klasy parsera w Alpaca}
\label{sec:parser-lr1-choice}

Alpaca generuje parsery klasy LR(1), czyli deterministyczne analizatory korzystające
z pełnego jednego tokena lookaheadu oraz kanonicznych stanów LR. Taki wybór łączy
wysoką moc wyrazu (obsługa lewostronnej rekurencji, gramatyk o złożonej składni)
z przewidywalnością działania i stabilnym czasem parsowania.

\subsection{Zalety LR(1) w Alpaca}
\begin{itemize}
    \item LR(1) obejmuje znacznie więcej konstrukcji niż LL(k)
    i unika wymuszonych przeróbek gramatyki (eliminacji lewej rekurencji, agresywnej lewostronnej faktoryzacji).
    Dzięki temu specyfikacja pozostaje bliższa naturalnej formie języka.

    \item Pełny lookahead eliminuje typowe dla SLR i LALR konflikty,
    które wynikają z nadmiernie szerokich FOLLOW-ów. Dzięki temu w gramatyce pojawia się mniej konfliktów.

    \item Stany LR(1) pozwalają jasno wskazać, jaki był oczekiwany token
    w danym miejscu; pozwala to na bardziej precyzyjne komunikaty dotyczące błędów składniowych.

    \item Każdy krok analizatora to pojedynczy dostęp do tabeli (\texttt{shift/reduce}),
    co zapewnia stabilną wydajność liniową dla całego wejścia.

    \item Każda redukcja LR(1) jednoznacznie
    odpowiada konkretnej produkcji, oraz ma dostęp do terminali które ją tworzą,
    więc akcje semantyczne mogą bezpośrednio tworzyć węzły AST.
\end{itemize}

\subsection{Koszty i kompromisy}
\begin{itemize}
    \item Kanoniczne LR(1) może generować znacznie więcej stanów niż SLR/LALR.

    \item Obliczanie zbiorów closure i goto dla LR(1) jest bardziej
    kosztowne niż w uproszczonych wariantach, co wpływa na czas kompilacji i rozmiar generatora.

    \item Parser LR(1) jest deterministyczny składniowo, ale nie semantycznie; wciąż trzeba
    rozwiązywać niejednoznaczności (np. ``dangling else'') poprzez jawne reguły priorytetów.

    \item Choć klasa jest szeroka,
    nadal istnieją konstrukcje wymagające przekształceń.
\end{itemize}

\section{Konstrukcja tablic parsera LR(1) w Alpaca}
\label{sec:parser-impl-overview}

Wygenerowanie parsera LR(1) w Alpaca to sekwencja algorytmów wykonywanych w czasie kompilacji. Poniżej opisano, krok po kroku, jak deklaratywna gramatyka staje się deterministyczną tabelą akcji.

\subsection{Wyznaczanie zbiorów FIRST}
Na bazie produkcji wyliczany jest \texttt{FirstSet} (iteracyjnie do punktu stałego), który określa możliwe terminale po kropce. Algorytm przechodzi po wszystkich produkcjach, dodając:
\begin{itemize}
    \item pierwszy terminal z prawej strony produkcji,
    \item w przypadku nieterminali — wszystkie terminale z ich FIRST (z wyjątkiem $\varepsilon$), a jeśli mogą generować $\varepsilon$, iteruje dalej po kolejnych symbolach produkcji,
    \item $\varepsilon$ dla produkcji pustych.
\end{itemize}

\lstinputlisting[language=scala,caption={Implementacja metody addImports używanej podczas wyznaczania zbiorów FIRST},label={lst:add-imports-impl}]{listings/chapter5/add-imports-impl.scala}

Pętla powtarza się, aż zbiory FIRST przestaną się zmieniać (punkt stały)

\subsection{Budowa automatów LR(1)}
Stan początkowy to domknięcie elementu \texttt{S' → • root, \$}. Kolejne stany są
budowane klasycznym schematem \textit{closure}/\textit{goto} i deduplikowane, tak aby
otrzymać deterministyczny automat LR(1).

\subsubsection{Funkcja \texttt{closure}}
Dla elementu z nieterminalem po kropce (\(A \to \alpha \,\bullet\, B \beta,\, a\))
algorytm:
\begin{itemize}
    \item wylicza zbiór lookaheadów \(FIRST(\beta a)\), tj.\ \(FIRST(\beta)\)
          bez \(\varepsilon\) oraz, jeśli \(\varepsilon \in FIRST(\beta)\), dodaje także \(a\),
    \item dla każdego takiego lookaheadu \(x\) dodaje elementy
          \(B \to \bullet \gamma, x\) dla wszystkich produkcji \(B \to \gamma\),
    \item rekurencyjnie domyka nowo dodane elementy, dopóki dodawanie kolejnych produkcji
          nie generuje nowych elementów (closure osiąga punkt stały).
\end{itemize}
W efekcie stan zawiera pełen zbiór ,,przewidywań'' dla wszystkich nieterminali,
które mogą pojawić się w tej pozycji po kropce.

\lstinputlisting[language=scala,caption={Implementacja funkcji `closure`},label={lst:lr1-closure}]{listings/chapter5/lr1-closure.scala}

\subsubsection{Funkcja \texttt{goto}}
Dla zadanego stanu i symbolu \(s\) po kropce, funkcja \texttt{goto} przesuwa kropkę
we wszystkich elementach z tym symbolem i domyka wynik, korzystając z produkcji
i wcześniej policzonych zbiorów FIRST.

\lstinputlisting[language=scala,caption={Implementacja funkcji `goto`},label={lst:lr1-goto}]{listings/chapter5/lr1-goto.scala}

\subsubsection{Główny algorytm budowy automatów LR(1)}
Konstrukcja automatów LR(1) rozpoczyna się od stanu początkowego i iteracyjnie dodaje nowe stany, dopóki wszystkie przejścia nie zostaną odkryte. Proces ten można podzielić na cztery główne etapy:
\begin{itemize}
    \item Domknięcie elementu \texttt{S' → • root, \$} tworzy stan~0.
    \item Dla każdego stanu zbierane są symbole, które mogą wystąpić po kropce;
          dla każdego takiego symbolu wyliczany jest stan docelowy funkcją \texttt{goto}. Jeśli
          stan docelowy już istnieje, do tabeli dopisywany jest \textit{shift} do jego ID; w przeciwnym
          razie stan otrzymuje nowe ID, jest dodawany do listy stanów, a \textit{shift} wskazuje na niego.
    \item Elementy z kropką na końcu produkcji dodają akcje
          \textit{reduce} dla swoich lookaheadów; w szczególnym przypadku element
          \texttt{S' → root •, \$} generuje akcję \textit{accept} dla symbolu \texttt{\$}.
    \item Algorytm powtarza te kroki, dopóki nie zostaną przetworzone
          wszystkie utworzone stany; identyczne zestawy elementów nie tworzą nowych stanów,
          dzięki czemu automat pozostaje deterministyczny.
\end{itemize}

\lstinputlisting[language=scala,caption={Główny algorytm budowy automatów LR(1)},label={lst:lr1-build}]{listings/chapter5/lr1-build.scala}

Stany są kolekcjami \texttt{Item}-ów przechowywanymi w posortowanym zbiorze, więc są porównywane
strukturalnie po zawartości, a nie po referencji.

% TODO: implement error resolution cycle identification and cover the the whole topic here
