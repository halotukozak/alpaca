\chapter{Implementacja}\label{ch:implementacja}

\section{Praktyczna implementacja analizatora leksykalnego z~wykorzystaniem makr w~Scali~3}\label{sec:praktyczna-implementacja-analizatora-leksykalnego-z-wykorzystaniem-makr-w-scali-3}

\subsection{Wprowadzenie do studium przypadku}\label{subsec:wprowadzenie-do-studium-przypadku}

W niniejszym rozdziale przedstawiono implementację systemu analizy leksykalnej wykorzystującego mechanizmy metaprogramowania Scali~3~\cite{scala3-reference-macros}. System dokonuje transformacji deklaratywnych reguł tokenizacji, wyrażonych w~języku dziedzinowym (DSL), w~kod wykonywany w~czasie kompilacji. Zastosowano refleksję TASTy~\cite{scala3-reflection} oraz typy rafinowane~\cite{scala3-selectable}.

Moduł \texttt{alpaca.lexer} realizuje konwersję funkcji częściowych na skompilowany kod proceduralny, wykorzystując pełne API refleksji TASTy.

\subsection{Architektura systemu leksera}\label{subsec:architektura-systemu-leksera}

\subsubsection{Interfejs użytkownika}\label{subsubsec:interfejs-uzytkownika}

Interfejs języka dziedzinowego oparto na dopasowaniu wzorców:

\lstinputlisting[language=scala,caption={Definicja typu LexerDefinition},label={lst:lexer-definition}]{listings/implementation/01-lexer-definition.scala}

Typ \texttt{LexerDefinition} modeluje reguły jako funkcję częściową z~wzorców na tokeny, co umożliwia idiomatyczne definiowanie reguł leksykalnych.

Główny punkt wejścia stanowi metoda \texttt{lexer}:

\lstinputlisting[language=scala,caption={Punkt wejścia: transparent inline def lexer},label={lst:lexer-entrypoint}]{listings/implementation/02-lexer-entrypoint.scala}

Modyfikator \texttt{transparent inline} gwarantuje precyzyjne typowanie zwracanej struktury~\cite{scala3-reference-macros}.

\subsubsection{Implementacja makra}\label{subsubsec:implementacja-makra}

Makro przetwarza parametr \verb|Expr[Ctx ?=> LexerDefinition[Ctx]]| z~kontekstualnymi klasami pomocniczymi. Dostęp do refleksji zapewniany jest przez \texttt{Quotes}~\cite{scala3-guides-quotes}.

\subsection{Analiza drzewa składni abstrakcyjnej}\label{subsec:analiza-drzewa-skladni-abstrakcyjnej}

Na podstawie wyekstrahowanych reguł następuje ich transformacja~\cite{scala3-guides-reflection}.

\subsubsection{Dekonstrukcja funkcji częściowej}\label{subsubsec:dekonstrukcja-funkcji-czesciowej}

Ekstrakcja reguł realizowana jest przez dopasowanie AST:

\lstinputlisting[language=scala,caption={Dekonstrukcja funkcji częściowej},label={lst:extract-cases}]{listings/implementation/03-extract-case.scala}

Struktura \texttt{Lambda(Match(cases))} odpowiada reprezentacji funkcji częściowej w~TASTy.

\subsection{Transformacja referencji}\label{subsec:transformacja-i-adaptacja-referencji}

\subsubsection{Zastępowanie kontekstu}\label{subsubsec:klasa-replacerefs}

Referencje do kontekstu zastępowane są nowymi~\cite{scala3-guides-reflection}:

\lstinputlisting[language=scala,caption={Zastąpienie referencji kontekstu},label={lst:replace-with-new-ctx}]{listings/implementation/04-replace-refs-with-new-ctx.scala}

Transformacja realizuje przepisanie właściciela symboli w~drzewie AST.

\subsection{Ekstrakcja i kompilacja wzorców}\label{subsec:ekstrakcja-i-kompilacja-wzorcow}

\subsubsection{Dopasowanie definicji tokenów}\label{subsubsec:funkcja-extractsimple}

Funkcja \texttt{extractSimple} analizuje warianty tokenów:

\lstinputlisting[language=scala,caption={Dopasowanie definicji tokenów},label={lst:lexer-08-extract-simple}]{listings/implementation/05-extract-simple.scala}

Ekstraktor typów~\cite{scala3-guides-quotes} umożliwia typobezpieczne przetwarzanie.

\subsection{Generacja klasy anonimowej}\label{subsec:generacja-klasy-anonimowej}

Klasa implementująca \texttt{Tokenization[Ctx]} tworzona jest dynamicznie~\cite{stucki2021multistage}.

\subsubsection{Konstrukcja symbolu klasy}\label{subsubsec:konstrukcja-symbolu-klasy}

\texttt{Symbol.newClass} przyjmuje właściciela, nazwę, typy bazowe oraz deklaracje~\cite{scala3-guides-reflection}.

\subsubsection{Członkowie klasy}\label{subsubsec:definicja-czlonkow-klasy}

Deklaracje obejmują pola tokenów, alias \texttt{Fields}, pola \texttt{compiled} i~\texttt{tokens}.

\subsection{Typy rafinowane}\label{subsec:typy-rafinowane}

Typy rafinowane dodają informacje o~tokenach w~czasie kompilacji~\cite{scala3-selectable}:

\lstinputlisting[language=scala,caption={Rafinowanie typu wynikowego},label={lst:refinements}]{listings/implementation/06-refinements.scala}

Wynikowy typ to przecięcie \texttt{Tokenization[Ctx] & { val TOKEN: DefinedToken[...] }}.

\subsection{Uzasadnienie implementacji}\label{subsec:uzasadnienie-wybranego-podejscia}

\subsubsection{Wydajność}\label{subsubsec:eliminacja-narzutu-wykonania}

Dostęp do tokenów (\texttt{getfield}) osiąga złożoność~O(1)~\cite{lindholm2014java}.

\subsubsection{Bezpieczeństwo typów}\label{subsubsec:bezpieczenstwo-typow}

Precyzyjne typowanie eliminuje błędy w~czasie kompilacji~\cite{scala3-selectable}.

\subsection{Analiza alternatyw}\label{subsec:analiza-alternatywnych-rozwiazan}

Mapowanie dynamiczne traci bezpieczeństwo typów i~wprowadza narzut haszowania.
Jawna definicja klasy generuje redundancję kodu.

\subsection{Walidacja błędów}\label{subsec:walidacja-i-obsuga-bedow}

\texttt{RegexChecker} weryfikuje wzorce w~czasie kompilacji~\cite{scala3-reference-macros}.