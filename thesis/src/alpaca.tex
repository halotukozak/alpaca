%%%%%% -*- Coding: utf-8-unix; Mode: latex

\documentclass[polish]{aghengthesis}

\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage{url}
\usepackage{subfigure}
\usepackage{ragged2e}
\usepackage{multirow}
\usepackage{grffile}
\usepackage{indentfirst}
\usepackage{listings}
\usepackage[ruled,linesnumbered,lined]{algorithm2e}
\usepackage{caption}
\usepackage[bookmarks=false]{hyperref}

\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{array}
\usepackage[table]{xcolor}

\hypersetup{colorlinks,
    linkcolor=blue,
    citecolor=blue,
    urlcolor=blue}

\usepackage[svgnames]{xcolor}
\usepackage{inconsolata}

\usepackage{csquotes}
\DeclareQuoteStyle[quotes]{polish}
{\quotedblbase}
{\textquotedblright}
[0.05em]
{\quotesinglbase}
{\fixligatures\textquoteright}
\DeclareQuoteAlias[quotes]{polish}{polish}

\usepackage[nottoc]{tocbibind}

\usepackage[
    style=numeric,
    sorting=none,
    isbn=false,
    doi=true,
    url=true,
    backref=false,
    backrefstyle=none,
    maxnames=10,
    giveninits=true,
    abbreviate=true,
    defernumbers=false,
    backend=biber]{biblatex}
\addbibresource{bibliografia.bib}

\lstdefinelanguage{terminal}{
    breaklines=true,
    breakatwhitespace=false,
}

\lstdefinelanguage{Scala}{
    morekeywords={
        abstract,case,catch,class,def,do,else,
        enum,export,extends,false,final,finally,for,
        given,if,implicit,import,lazy,match,new,
        null,object,override,package,private,protected,return,
        sealed,super,then,throw,trait,true,try,
        type,val,var,while,with,yield,
        as,derives,end,extension,infix,inline,opaque,open,transparent,using},
    otherkeywords={<-,=>,<:,>:,@,=>>,?=>,|,*},
    sensitive=true,
    morecomment=[l]{//},
    morecomment=[n]{/*}{*/},
    morecomment=[n]{/**}{*/},
    morestring=[b]",
    morestring=[b]``''"
}[keywords,comments,strings]

\lstdefinelanguage{json}{
    breaklines=true,
    breakatwhitespace=false,
}

\usepackage{fontspec}
\setmonofont{JetBrains Mono}[Contextuals=Alternate]

\lstset{
    basicstyle=\ttfamily\footnotesize,
    backgroundcolor=\color{white},
    commentstyle=\it\color{Green},
    keywordstyle=\color{Red},
    stringstyle=\color{Blue},
    numberstyle=\tiny\color{Black},
    escapeinside=`',
    frame=single,
    tabsize=2,
    rulecolor=\color{black!30},
    title=\lstname,
    breaklines=true,
    breakatwhitespace=true,
    framextopmargin=2pt,
    framexbottommargin=2pt,
    extendedchars=false,
    captionpos=b,
    abovecaptionskip=5pt,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2
}

\SetAlgorithmName{\LangAlgorithm}{\LangAlgorithmRef}{\LangListOfAlgorithms}
\newcommand{\listofalgorithmes}{\tocfile{\listalgorithmcfname}{loa}}

\renewcommand{\lstlistingname}{\LangListing}
\renewcommand\lstlistlistingname{\LangListOfListings}

\renewcommand{\lstlistoflistings}{\begingroup
\tocfile{\lstlistlistingname}{lol}
\endgroup}

% Definicje nowych rodzajów kolumn w tabeli
\newcolumntype{C}{>{\centering\arraybackslash}m{0.15\linewidth}}
\newcolumntype{L}{>{\raggedright\arraybackslash}m{0.15\linewidth}}
\newcolumntype{Y}{>{\centering\arraybackslash}X}
\newcolumntype{Z}{>{\raggedleft\arraybackslash}X}

\captionsetup{
    font=small,
    labelfont=bf,
    labelsep=period,
    skip=5pt
}
\captionsetup[figure]{position=bottom}
\captionsetup[table]{position=bottom}
\captionsetup[lstlisting]{position=bottom}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\author{Bartosz Buczek, Bartłomiej Kozak}

\titlePL{Implementacja narzędzi lex i yacc z wykorzystaniem metaprogramowania}
\titleEN{Implementation of lexical analyzer (lex) and parser generator (yacc) tools using metaprogramming techniques}

\fieldofstudy{Informatyka}

%\typeofstudies{Stacjonarne}

\supervisor{dr inż.\ Tomasz Służalec}

\date{\the\year}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

    \maketitle

    \thispagestyle{empty}

    \vspace*{\fill}

    \begin{center}
        \large
        \textit{I do see the beauty in the rules, the invisible code of chaos\\
        hiding behind the menacing face of order.}

        \vspace{0.5cm}

        \normalsize
        --- Elliot Alderson, \textit{Mr. Robot (episode eps2.0\_unm4sk-pt1.tc)}
    \end{center}

    \vspace*{\fill}

    \clearpage
    \thispagestyle{empty}
    \vspace*{\fill}
    \clearpage

    \begin{center}
        {\bfseries Abstrakt}
    \end{center}

    \small
    Analizatory leksykalne i składniowe stanowią fundamentalne komponenty procesu kompilacji, realizując fazy transformacji ciągu znaków wejściowych na strumień tokenów oraz weryfikacji zgodności strukturalnej z gramatyką.
    Istniejące narzędzia do konstruowania tych analizatorów wykazują istotne ograniczenia w kontekście nowoczesnych języków programowania oraz funkcji oferowanych przez zintegrowane środowiska deweloperskie.
    Popularne generatory kodu takie jak Lex/Yacc i ANTLR wymagają zewnętrznych etapów budowania i znajomości języków domenowych, podczas gdy biblioteki interpretowane jak PLY i SLY cechują się słabą wydajnością i ograniczonym bezpieczeństwem typów.
    Kombinatory parserów oferują elastyczność w opisie i modyfikacji składni języka, jednak często wiążą się z dodatkowym narzutem wykonania zmniejszającym wydajność w porównaniu do podejść generacyjnych.
    Niniejsza praca przedstawia bibliotekę ALPACA (Another Lexer Parser And Compiler Alpaca) – narzędzie opracowane w Scali 3, które korzystając z możliwości metaprogramowania w czasie kompilacji, łączy wydajność generatorów kodu z użytecznością bibliotek.
    Teza badawcza postuluje, że wykorzystanie makr Scali 3, mechanizmu cytatów i wstawek oraz typów rafinowanych umożliwia konstrukcję lekserów i parserów o trzech kluczowych właściwościach.
    Po pierwsze, zapewniają one wydajność parsowania porównywalną z innymi narzędziami.
    Po drugie, oferują interfejs programistyczny niezależny od zewnętrznych języków domenowych i w pełni zintegrowany z systemem typów Scali.
    Po trzecie, dostarczają diagnostykę błędów w czasie kompilacji.
    Metodologia wykorzystuje API refleksji TASTy do programatycznego generowania klas anonimowych implementujących logikę tokenizacji i parsowania w trakcie kompilacji.
    Analiza leksykalna opiera się na wyrażeniach regularnych, zaś analiza składniowa implementuje algorytmy konstrukcji parserów LR(1).
    Implementacja rozwiązuje krytyczne ograniczenia JVM poprzez techniki fragmentacji metod, umożliwiając kompilację złożonych gramatyk.
    Akcje semantyczne zachowują bezpieczeństwo typów poprzez transformacje AST i przepisywanie referencji między etapami kompilacji.
    Kluczowe wkłady techniczne obejmują deklaratywną specyfikację gramatyki zintegrowaną z dopasowaniem wzorców i systemem typów Scali, eliminując potrzebę specjalnego DSL\@.
    Typy rafinowane zapewniają statycznie weryfikowany dostęp do pól tokenów z pełnym wsparciem IDE, obejmującym autouzupełnianie, podpowiedzi typów i nawigację do definicji.
    Dodatkowe mechanizmy obejmują automatyczne rozwiązywanie konfliktów poprzez relacje precedencji oraz walidację gramatyki w czasie kompilacji z komunikatami błędów zawierającymi praktyczne informacje.
    Walidacja empiryczna porównuje rozwiązanie z innymi narzędziami za pomocą testów wydajnościowych, które obejmują wyrażenia arytmetyczne oraz parsowanie plików w formacie JSON. Wyniki wykazują wydajność konkurencyjną wobec podobnych rozwiązań dla struktur iteracyjnych i utrzymywaniu stabilnej wydajności przy głębokim zagnieżdżeniu.
    Implementacja oferuje poprawę użyteczności w porównaniu do wszystkich analizowanych alternatyw.
    Badania skutecznie weryfikują hipotezę, że metaprogramowanie w czasie kompilacji może zapewniać wysoką wydajność, przy jednoczesnym zachowaniu użyteczności bibliotek i integracji z IDE.
    Praca ta może zostać z powodzeniem wykorzystana w edukacji teorii kompilacji i tworzeniu języków domenowych, z potencjalnym wpływem na sposób, w jaki nowoczesne narzędzia językowe równoważą wydajność, bezpieczeństwo typów i doświadczenie programisty.
    \vspace{1cm}

    {\bfseries Słowa kluczowe:} metaprogramowanie, Scala 3, makra, analizator leksykalny, parser składniowy, parser LR(1), quote-splice, typy rafinowane, generowanie kodu, refleksja TASTy, bezpieczeństwo typów, optymalizacja kompilacji, integracja IDE, gramatyki bezkontekstowe.

    \newpage

    \begin{center}
        {\bfseries Abstract}
    \end{center}

    \small
    Lexical and syntactic analyzers are fundamental components in compiler construction, implementing phases that transform character sequences into token streams and verify structural conformance to grammars.
    Existing tools for constructing these analyzers exhibit significant limitations when applied to modern programming languages and integrated development environments.
    Traditional code generators like Lex/Yacc and ANTLR require external build steps and learning domain-specific language, while interpreted libraries such as PLY and SLY suffer from poor performance and limited type safety.
    Parser combinator libraries offer flexibility but introduce runtime overhead that diminishes performance compared to code generation approaches.
    This thesis presents ALPACA (Another Lexer Parser And Compiler Alpaca), a tool developed in Scala 3 that synthesizes the performance benefits of code generators with the usability of libraries through Scala 3's compile-time metaprogramming capabilities.
    The research thesis posits that utilizing Scala 3 macros, quote-splice mechanisms, and refined types enables construction of lexers and parsers with three key properties.
    Firstly, parsing performance comparable to other tools.
    Secondly, usable APIs independent of external domain-specific languages and fully integrated with Scala's type system.
    Thirdly, compile-time error diagnostics.
    The methodology employs TASTy reflection API to programmatically generate anonymous classes implementing tokenization and parsing logic during compilation.
    Lexical analysis leverages regular expressions, while syntactic analysis implements LR(1) parser construction algorithms entirely at compile-time.
    The implementation addresses critical JVM constraints through method fragmentation techniques, enabling compilation of complex grammars.
    Semantic actions maintain type safety through AST transformation and cross-stage reference rewriting.
    Key technical contributions include declarative grammar specification integrated with Scala's pattern matching and type system, eliminating the need for a special DSL.
    Refined types provide statically-verified token field access with comprehensive IDE support, including autocomplete, type hints, and go-to-definition navigation.
    Additional contributions encompass automatic conflict resolution through precedence relations and compile-time grammar validation with error messages containing practical information.
    Empirical validation compares ALPACA against other solutions across arithmetic expressions and JSON parsing benchmarks.
    Results demonstrate competitive performance with the other tools.
    The solution offers improved usability compared to all analyzed alternatives.
    The research successfully validates the hypothesis that compile-time metaprogramming can achieve equivalent performance while preserving library-like usability and IDE integration.
    This work demonstrates practical applications in compiler education and domain-specific language development, with potential impact on how modern language tooling balances performance, type safety, and developer experience.

    \vspace{1cm}
    {\bfseries Keywords:} metaprogramming, Scala 3, macros, lexical analyzer, LR(1) parser, quote-splice mechanisms, refined types, code generation, TASTy reflection, type safety, compilation optimization, IDE integration, context-free grammars.

    \clearpage

    \tableofcontents

    \include{introduction}

    \include{metaprogramming}

    \include{implementation}

    \include{lexer-algo}

    \include{parser-algo}

    \include{comparison}

    \include{organization}

    \printbibliography[heading=bibintoc]
    \listoffigures
    \listoftables
% \listofalgorithmes
    \lstlistoflistings

\end{document}
