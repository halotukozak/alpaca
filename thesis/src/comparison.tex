\chapter[Analiza porównawcza z istniejącymi rozwiązaniami]{Analiza porównawcza z~istniejącymi rozwiązaniami}
\label{ch:comp}


\section{Wprowadzenie do badań porównawczych}
\label{sec:comp-intro}

Weryfikacja empiryczna tezy pracy wymaga systematycznego porównania systemu~\emph{ALPACA} z~reprezentatywnymi rozwiązaniami istniejącymi na~rynku.
W~tym celu przeprowadzono serię testów wydajnościowych (ang.~\emph{benchmarks}), których metodologia, wyniki oraz interpretacja zostaną przedstawione w~niniejszym rozdziale.

Wybór narzędzi porównawczych wynikał z~analizy przeprowadzonej w~sekcji~\ref{sec:intro-review}.
Jako rozwiązania reprezentatywne dla głównych kategorii wybrano: SLY~\cite{sly} --- bibliotekę dla języka Python, reprezentującą podejście oparte na~refleksji i~dynamicznym typowaniu (kategoria bibliotek w językach interpretowanych) oraz FastParse~\cite{fastparse-docs} --- bibliotekę kombinatorów parserów dla Scali, reprezentującą nowoczesne podejście do~budowy parserów w~językach statycznie typowanych (kategoria kombinatorów parserów).

Wybór tych narzędzi uzasadniony jest ich reprezentatywnością dla różnych paradygmatów konstrukcji parserów oraz dostępnością dokumentacji i~aktywnym wsparciem społeczności.
Pominięto generatory kodu takie jak ANTLR ze~względu na~różnice w~architekturze (zewnętrzny krok generacji vs.~metaprogramowanie w~czasie kompilacji), które utrudniają bezpośrednie porównanie wydajności.


\section{Metodologia badań}
\label{sec:comp-methodology}

\subsection{Środowisko testowe}
\label{subsec:comp-env}

Wszystkie testy zostały przeprowadzone w~kontrolowanym środowisku o~następujących parametrach.

\begin{table}[ht]
    \centering
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Parametr} & \textbf{Wartość} \\
        \hline
        Procesor & Apple M4 Pro, 14 rdzeni \\
        \hline
        Pamięć RAM & 48 GB \\
        \hline
        System operacyjny & macOS Sequoia 15.6 \\
        \hline
        JVM & OpenJDK 21.0.8 \\
        \hline
        Python & 3.13.5 \\
        \hline
        Scala & 3.8.0-RC1 \\
        \hline
    \end{tabular}
    \caption{Parametry środowiska wykorzystanego do przeprowadzenia testów wydajnościowych.}
    \label{tab:comp-env}
\end{table}

Przed każdym pomiarem wykonywano fazę rozgrzewki (ang.~\emph{warmup}) składającą się z~trzech iteracji, co~pozwalało na~optymalizację kodu przez kompilator JIT~\cite{lindholm2014java} oraz stabilizację pamięci podręcznej procesora.
Każdy test był powtarzany 10~razy, a~wyniki uśredniano w~celu redukcji wpływu losowych wahań wydajności.

\subsection{Charakterystyka danych testowych}
\label{subsec:comp-data}

Testy wydajnościowe przeprowadzono na~dwóch rodzajach gramatyk: prostej gramatyce wyrażeń arytmetycznych oraz gramatyce formatu JSON\@.
Dla każdej gramatyki przygotowano dwa typy danych wejściowych różniące się strukturą.

\subsubsection{Dane iteracyjne}
\label{subsubsec:comp-data-iter}

Dane iteracyjne charakteryzują się płaską strukturą składniową bez głębokiego zagnieżdżenia.
Dla wyrażeń arytmetycznych przyjęto formę ciągu operacji.

\lstinputlisting[language=terminal,caption={Struktura iteracyjnych danych testowych dla wyrażeń arytmetycznych.},label={lst:comp-iter-math}]{listings/comparison/iterative-math-structure.txt}

Dla formatu JSON dane iteracyjne reprezentują tablicę obiektów o~stałej głębokości zagnieżdżenia.

\lstinputlisting[language=json,caption={Struktura iteracyjnych danych testowych dla JSON.},label={lst:comp-iter-json}]{listings/comparison/iterative-json-structure.json}

\subsubsection{Dane rekurencyjne}
\label{subsubsec:comp-data-recur}

Dane rekurencyjne charakteryzują się głębokim zagnieżdżeniem struktur składniowych, co~stanowi wyzwanie dla parserów ze~względu na~wykorzystanie stosu wywołań.
Dla wyrażeń arytmetycznych przyjęto formę zagnieżdżonych nawiasów.

\newpage

\lstinputlisting[language=terminal,caption={Struktura rekurencyjnych danych testowych dla wyrażeń arytmetycznych.},label={lst:comp-recur-math}]{listings/comparison/recursive-math-structure.txt}

Dla formatu JSON dane rekurencyjne reprezentują głęboko zagnieżdżone obiekty.

\lstinputlisting[language=json,caption={Struktura rekurencyjnych danych testowych dla JSON.},label={lst:comp-recur-json}]{listings/comparison/recursive-json-structure.json}

\subsection{Scenariusze testowe}
\label{subsec:comp-scenarios}

Pomiary przeprowadzono dla rozmiarów danych wejściowych: 100, 500, 1000 oraz 2000~elementów (linii lub obiektów w~przypadku JSON).

\noindent Dla każdego rozmiaru mierzono następujące metryki:

\begin{itemize}
    \item Czas leksykalizacji (ang.~\emph{lex time}) --- czas przekształcenia tekstu wejściowego w~strumień tokenów (dotyczy ALPACA i~SLY, które wyróżniają fazę leksykalizacji),
    \item Czas parsowania (ang.~\emph{parse time}) --- czas analizy składniowej strumienia tokenów,
    \item Całkowity czas przetwarzania (ang.~\emph{full parse time}) --- łączny czas leksykalizacji i~parsowania.
\end{itemize}

FastParse realizuje leksykalizację i~parsowanie w~jednym przebiegu, dlatego dla tej biblioteki mierzono wyłącznie całkowity czas przetwarzania.


\section{Implementacja parserów testowych}
\label{sec:comp-impl}

W~celu zapewnienia porównywalności wyników, dla każdego narzędzia zaimplementowano funkcjonalnie równoważne parsery wyrażeń arytmetycznych oraz formatu JSON\@.
Wszystkie implementacje realizują bezpośrednią ewaluację (obliczenie wartości wyrażenia) zamiast konstrukcji drzewa AST, co~eliminuje różnice wydajnościowe wynikające ze~strategii alokacji pamięci.

\newpage

\subsection[Implementacja w ALPACA]{Implementacja w~ALPACA}
\label{subsec:comp-impl-alpaca}

Parser wyrażeń arytmetycznych w~systemie~\emph{ALPACA} wykorzystuje deklaratywny interfejs DSL oparty na~dopasowaniu wzorców.

\lstinputlisting[language=scala,caption={Parser wyrażeń arytmetycznych w~systemie ALPACA.},label={lst:comp-alpaca-math},escapeinside={(*@}{@*)}]{listings/comparison/alpaca-math-parser.scala}

\newpage
\subsection[Implementacja w SLY]{Implementacja w~SLY}
\label{subsec:comp-impl-sly}

Odpowiadająca implementacja w~bibliotece SLY wykorzystuje dekoratory i~refleksję nazw metod.

\lstinputlisting[language=python,caption={Parser wyrażeń arytmetycznych w~bibliotece SLY.},label={lst:comp-sly-math}]{listings/comparison/sly-math-parser.py}

\newpage

\subsection[Implementacja w FastParse]{Implementacja w~FastParse}
\label{subsec:comp-impl-fastparse}

FastParse realizuje parsowanie poprzez kompozycję funkcji parserowych.

\lstinputlisting[language=scala,caption={Parser wyrażeń arytmetycznych w~bibliotece FastParse.},label={lst:comp-fastparse-math}]{listings/comparison/fastparse-math-parser.scala}

Charakterystyczną cechą FastParse jest brak wydzielonej fazy leksykalizacji --- tokenizacja i~parsowanie są realizowane w~jednym przebiegu poprzez kompozycję parserów elementarnych.


\section{Wyniki badań}
\label{sec:comp-results}

\subsection{Wyrażenia arytmetyczne --- dane iteracyjne}
\label{subsec:comp-res-iter-math}

Tabela~\ref{tab:comp-res-iter-math} przedstawia wyniki testów wydajnościowych dla wyrażeń arytmetycznych o~strukturze iteracyjnej.

\begin{table}[ht]
    \centering
    \begin{tabularx}{\textwidth}{l|*{3}{Y}|*{3}{Y}|Y}
        \toprule
        \multirow{2}{*}{\textbf{Rozmiar}} & \multicolumn{3}{c|}{\small\textbf{ALPACA}} & \multicolumn{3}{c|}{\small\textbf{SLY}} & \small\textbf{FastParse}                                               \\
                                          & Lex                                  & Parse                             & Razem              & Lex      & Parse     & Razem     & Razem    \\
        \midrule 
        \smaller100                               & \smaller16,85~ms                             & \smaller8,49~ms                           & \smaller16,48~ms           & \smaller1,52~ms  & \smaller6,69~ms   & \smaller8,24~ms   & \smaller6,13~ms  \\
        \smaller500                               & \smaller41,94~ms                             & \smaller17,63~ms                          & \smaller30,07~ms           & \smaller7,98~ms  & \smaller31,18~ms  & \smaller38,57~ms  & \smaller14,13~ms \\
        \smaller1000                              & \smaller40,58~ms                             & \smaller10,95~ms                          & \smaller77,24~ms           & \smaller14,84~ms & \smaller59,65~ms  & \smaller76,50~ms  & \smaller21,24~ms \\
        \smaller2000                              & \smaller166,89~ms                            & \smaller21,22~ms                          & \smaller188,56~ms          & \smaller30,61~ms & \smaller124,52~ms & \smaller156,70~ms & \smaller7,73~ms  \\
        \bottomrule
    \end{tabularx}
    \caption{Wyniki testów wydajnościowych dla wyrażeń arytmetycznych (dane iteracyjne).}
    \label{tab:comp-res-iter-math}
\end{table}

\subsection{Wyrażenia arytmetyczne --- dane rekurencyjne}
\label{subsec:comp-res-recur-math}

Tabela~\ref{tab:comp-res-recur-math} przedstawia wyniki dla wyrażeń arytmetycznych o~strukturze rekurencyjnej (głębokie zagnieżdżenie nawiasów).

\begin{table}[ht]
    \centering
    \begin{tabularx}{\textwidth}{l|*{3}{Y}|*{3}{Y}|Y}
        \toprule
        \multirow{2}{*}{\textbf{Rozmiar}} & \multicolumn{3}{c|}{\small\textbf{ALPACA}} & \multicolumn{3}{c|}{\small\textbf{SLY}} & \small\textbf{FastParse}                                                                 \\
                                          & Lex                                  & Parse                             & Razem              & Lex      & Parse     & Razem     & Razem                      \\
        \midrule
        \smaller100                               & \smaller3,55~ms                              & \smaller1,70~ms                           & \smaller4,96~ms            & \smaller1,79~ms  & \smaller7,27~ms   & \smaller9,25~ms   & \smaller3,10~ms                    \\
        \smaller500                               & \smaller27,70~ms                             & \smaller7,81~ms                           & \smaller29,92~ms           & \smaller10,45~ms & \smaller35,30~ms  & \smaller46,85~ms  & \smaller4,56~ms                    \\
        \smaller1000                              & \smaller63,79~ms                             & \smaller12,94~ms                          & \smaller80,08~ms           & \smaller20,22~ms & \smaller72,95~ms  & \smaller96,95~ms  & \smaller7,29~ms                    \\
        \smaller2000                              & \smaller220,96~ms                            & \smaller25,82~ms                          & \smaller274,95~ms          & \smaller43,06~ms & \smaller150,68~ms & \smaller194,77~ms & $\dagger$ \\
        \bottomrule
    \end{tabularx}
    \caption{Wyniki testów wydajnościowych dla wyrażeń arytmetycznych (dane rekurencyjne). $\dagger$ oznacza błąd przepełnienia stosu (\emph{StackOverflowError}).}
    \label{tab:comp-res-recur-math}
\end{table}

Wyniki ujawniają istotne ograniczenie biblioteki FastParse: dla danych rekurencyjnych o~głębokości przekraczającej 1000~poziomów zagnieżdżenia występuje błąd przepełnienia stosu (ang.~\emph{StackOverflowError}).
Jest to~konsekwencją architektury kombinatorów parserów, które realizują rekurencję poprzez stos wywołań JVM\@.

\subsection{Format JSON --- dane iteracyjne}
\label{subsec:comp-res-iter-json}

Tabela~\ref{tab:comp-res-iter-json} przedstawia wyniki dla formatu JSON o~strukturze iteracyjnej (tablica obiektów).

\begin{table}[ht]
    \centering
    \begin{tabularx}{\textwidth}{l|*{3}{Y}|*{3}{Y}|Y}
        \toprule
        \multirow{2}{*}{\textbf{Rozmiar}} & \multicolumn{3}{c|}{\small\textbf{ALPACA}} & \multicolumn{3}{c|}{\small\textbf{SLY}} & \small\textbf{FastParse}                                                \\
                                          & Lex                                  & Parse                             & Razem              & Lex       & Parse     & Razem     & Razem    \\
        \midrule
        \smaller100                               & \smaller30,63~ms                             & \smaller4,09~ms                           & \smaller26,27~ms           & \smaller7,22~ms   & \smaller17,07~ms  & \smaller24,88~ms  & \smaller15,82~ms \\
        \smaller500                               & \smaller144,00~ms                            & \smaller20,55~ms                          & \smaller164,02~ms          & \smaller35,60~ms  & \smaller87,15~ms  & \smaller131,62~ms & \smaller11,67~ms \\
        \smaller1000                              & \smaller478,19~ms                            & \smaller46,43~ms                          & \smaller555,45~ms          & \smaller75,34~ms  & \smaller182,93~ms & \smaller263,86~ms & \smaller12,64~ms \\
        \smaller2000                              & \smaller1,72~s                               & \smaller117,50~ms                         & \smaller1,58~s             & \smaller151,88~ms & \smaller374,71~ms & \smaller550,08~ms & \smaller16,58~ms \\
        \bottomrule
    \end{tabularx}
    \caption{Wyniki testów wydajnościowych dla formatu JSON (dane iteracyjne).}
    \label{tab:comp-res-iter-json}
\end{table}

\subsection{Format JSON --- dane rekurencyjne}
\label{subsec:comp-res-recur-json}

Tabela~\ref{tab:comp-res-recur-json} przedstawia wyniki dla formatu JSON o~strukturze rekurencyjnej (głęboko zagnieżdżone obiekty).

\begin{table}[ht]
    \centering
    \begin{tabularx}{\textwidth}{l|*{3}{Y}|*{3}{Y}|Y}
        \toprule
        \multirow{2}{*}{\textbf{Rozmiar}} & \multicolumn{3}{c|}{\small\textbf{ALPACA}} & \multicolumn{3}{c|}{\small\textbf{SLY}} & \small\textbf{FastParse}                                                 \\
                                          & Lex                                  & Parse                             & Razem              & Lex       & Parse     & Razem     & Razem     \\
        \midrule
        \smaller100                               & \smaller44,96~ms                             & \smaller4,33~ms                           & \smaller49,44~ms           & \smaller20,33~ms  & \smaller17,77~ms  & \smaller39,81~ms  & \smaller3,47~ms   \\
        \smaller500                               & \smaller2,99~s                               & \smaller18,09~ms                          & \smaller3,02~s             & \smaller358,04~ms & \smaller95,21~ms  & \smaller459,70~ms & \smaller15,19~ms  \\
        \smaller1000                              & \smaller23,55~s                              & \smaller37,51~ms                          & \smaller23,52~s            & \smaller1,36~s    & \smaller189,58~ms & \smaller1,58~s    & \smaller86,38~ms  \\
        \smaller2000                              & \textsuperscript{*}                  & \textsuperscript{*}               & \textsuperscript{*} & \smaller5,26~s    & \smaller385,47~ms & \smaller5,79~s    & \smaller346,44~ms \\
        \bottomrule
    \end{tabularx}
    \caption{Wyniki testów wydajnościowych dla formatu JSON (dane rekurencyjne).\\\textsuperscript{*} oznacza, że system nie zakończył pomiaru w~akceptowalnym czasie.}
    \label{tab:comp-res-recur-json}
\end{table}

Wyniki dla rekurencyjnych danych JSON ujawniają problem wydajnościowy w~module leksykalizacji systemu~\emph{ALPACA} dla danych o~wysokim stopniu zagnieżdżenia.
Czas leksykalizacji rośnie nieproporcjonalnie do~rozmiaru danych, co~wymaga dalszej analizy i~optymalizacji (sekcja~\ref{subsec:comp-conclusions}).


\section{Analiza wyników}
\label{sec:comp-analysis}

\subsection{Porównanie faz przetwarzania}
\label{subsec:comp-phases}

Analiza wyników ujawnia zróżnicowaną charakterystykę wydajnościową poszczególnych faz przetwarzania.

\subsubsection{Faza leksykalizacji}

Lekser biblioteki SLY wykazuje stabilną i~przewidywalną wydajność, charakteryzującą się liniową złożonością względem rozmiaru danych wejściowych.
Lekser systemu~\emph{ALPACA} osiąga porównywalną wydajność dla danych iteracyjnych, jednak wykazuje znaczący spadek wydajności dla danych rekurencyjnych JSON\@.

Przyczyną tego zachowania jest sposób obsługi białych znaków w~obu systemach.
W~danych testowych JSON każdy poziom zagnieżdżenia dodaje dwie spacje wcięcia.
Dla testu \texttt{recursive\_json\_2000} najbardziej zagnieżdżony obiekt jest wcięty za~pomocą 4000~spacji.
System~\emph{ALPACA} tokenizuje każdą sekwencję białych znaków jako osobny token typu \verb|Ignored|, co~wymaga dopasowania wzorca wyrażenia regularnego dla każdej spacji.

Biblioteka SLY stosuje odmienne podejście --- pomijanie ignorowanych znaków realizowane jest prostym warunkiem iteracyjnym.

\lstinputlisting[language=python,caption={Mechanizm pomijania białych znaków w~bibliotece SLY.},label={lst:comp-sly-ignore}]{listings/comparison/sly-ignore-mechanism.py}

To podejście eliminuje narzut związany z~dopasowaniem wyrażeń regularnych dla białych znaków, co~tłumaczy znaczącą przewagę wydajnościową SLY w~fazie leksykalizacji dla danych o~dużym stopniu zagnieżdżenia.
Optymalizacja mechanizmu ignorowania znaków stanowi kierunek przyszłych prac opisanych w~sekcji~\ref{subsec:comp-future}.

\subsubsection{Faza parsowania}

Faza parsowania systemu~\emph{ALPACA} wykazuje stabilną wydajność, znacząco przewyższającą bibliotekę \emph{SLY} dla wszystkich testowanych scenariuszy.
Różnica ta wynika z~różnic architektonicznych.
System~\emph{ALPACA} wykorzystuje tabele parsowania LR(1) generowane w~czasie kompilacji, co~eliminuje narzut interpretacji w~czasie wykonania.
Z~kolei biblioteka~\emph{SLY} interpretuje reguły gramatyczne w~czasie wykonania z~wykorzystaniem refleksji Pythona, co~wprowadza znaczący narzut.

\subsection{Zachowanie przy głębokim zagnieżdżeniu}
\label{subsec:comp-nesting}

Testy z~danymi rekurencyjnymi ujawniły istotne różnice w~obsłudze głęboko zagnieżdżonych struktur.
Biblioteka \emph{FastParse} wykazuje przepełnienie stosu dla głębokości zagnieżdżenia przekraczającej 1000--2000~poziomów, co~jest konsekwencją rekursywnej natury kombinatorów parserów.
System \emph{ALPACA} charakteryzuje się stabilnym działaniem parsera niezależnie od~głębokości zagnieżdżenia dzięki wykorzystaniu automatu ze~stosem zamiast rekurencji.
Biblioteka \emph{SLY} również wykazuje stabilne działanie dla wszystkich testowanych głębokości, analogicznie do~systemu \emph{ALPACA}.
Obserwacja ta potwierdza przewagę parserów LR nad kombinatorami parserów w~scenariuszach wymagających obsługi głęboko zagnieżdżonych struktur.

\subsection{Wnioski}
\label{subsec:comp-conclusions}

Przeprowadzone eksperymenty pozwalają na sformułowanie następujących wniosków dotyczących wydajności systemu \emph{ALPACA}.\\

\noindent Zalety systemu:
\begin{itemize}
    \item Faza parsowania systemu \emph{ALPACA} charakteryzuje się stabilną i przewidywalną wydajnością, przewyższającą bibliotekę \emph{SLY} we wszystkich analizowanych scenariuszach testowych.
    \item Zastosowanie parsera klasy LR(1) eliminuje ograniczenia wynikające z rozmiaru stosu wywołań, umożliwiając poprawne przetwarzanie struktur o dowolnej głębokości zagnieżdżenia.
    \item Liniowa złożoność czasowa procesu parsowania względem liczby tokenów zapewnia deterministyczne i przewidywalne czasy przetwarzania danych wejściowych.
\end{itemize}

\subsubsection{Obszary wymagające optymalizacji}
Mechanizm obsługi znaków ignorowanych wykazuje obniżoną wydajność w przypadku danych wejściowych charakteryzujących się dużym stopniem wcięcia. Wynika to z faktu, że każda sekwencja znaków białych jest tokenizowana jako osobna jednostka, co prowadzi do zwiększonego narzutu obliczeniowego.

\newpage
\section{Porównanie interfejsów programistycznych}
\label{sec:comp-api}

Oprócz wydajności, istotnym kryterium oceny narzędzi jest jakość interfejsu programistycznego (API).
Tabela~\ref{tab:comp-summary} zestawia kluczowe aspekty interfejsów porównywanych narzędzi.

\begin{table}[ht]
    \centering
    \begin{tabularx}{\textwidth}{X|C|C|C}
        \toprule
        \textbf{Kryterium}               & \textbf{ALPACA} & \textbf{SLY} & \textbf{FastParse} \\
        \midrule
        Wydajność parsowania             & wysoka          & niska        & wysoka             \\
        \hline
        Wydajność leksykalizacji         & średnia*        & wysoka       & nie dotyczy        \\
        \hline
        Obsługa głębokiego zagnieżdżenia & pełna           & pełna        & ograniczona        \\
        \hline
        Bezpieczeństwo typów             & pełne           & brak         & pełne              \\
        \hline
        Integracja IDE                   & pełna           & ograniczona  & pełna              \\
        \hline
        Diagnostyka błędów               & dobra           & średnia      & dobra              \\
        \bottomrule
    \end{tabularx}
    \caption{Podsumowanie analizy porównawczej (* wymaga optymalizacji mechanizmu ignorowania białych znaków).}
    \label{tab:comp-summary}
\end{table}

\subsection{Bezpieczeństwo typów}
\label{subsec:comp-api-types}

System~\emph{ALPACA} oferuje pełne bezpieczeństwo typów na~poziomie kompilacji dzięki wykorzystaniu typów rafinowanych (sekcja~\ref{subsec:impl-lexer-refinement}).
Każdy token i~wynik parsowania posiada precyzyjny typ znany kompilatorowi, co~umożliwia wykrywanie błędów przed uruchomieniem programu.

W~przeciwieństwie do~tego, biblioteka SLY wykorzystuje dynamiczne typowanie Pythona, co~oznacza, że~błędy typów są wykrywane dopiero w~czasie wykonania.
Fragment kodu~\ref{lst:comp-sly-type-error} ilustruje sytuację, w~której błąd typowania w~akcji semantycznej zostanie wykryty dopiero podczas parsowania konkretnego wejścia.

\lstinputlisting[language=python,caption={Błąd typowania wykrywany dopiero w~czasie wykonania (SLY).},label={lst:comp-sly-type-error}]{listings/comparison/sly-type-error.py}

\subsection[Integracja ze środowiskiem IDE]{Integracja ze~środowiskiem IDE}
\label{subsec:comp-api-ide}

System~\emph{ALPACA} oferuje pełną integrację ze~standardowymi narzędziami IDE dla języka Scala (IntelliJ IDEA, Metals) bez konieczności instalacji dedykowanych wtyczek.
Funkcjonalności takie jak: automatyczne uzupełnianie nazw tokenów, nawigacja do~definicji (\emph{go-to-definition}), prezentacja typów przy najechaniu kursorem oraz wykrywanie błędów w~czasie rzeczywistym są dostępne natywnie dzięki wykorzystaniu systemu typów Scali.

Biblioteka SLY, ze~względu na~wykorzystanie refleksji i~niestandardowych konwencji (nazwy metod jako produkcje, dekoratory~\verb|@_()|), oferuje ograniczone wsparcie IDE\@.
Analizatory statyczne, takie jak mypy, generują liczne błędy dla poprawnego kodu SLY, co~ilustruje fragment~\ref{lst:comp-mypy}.

\lstinputlisting[language=terminal,caption={Wynik analizy statycznej mypy dla parsera SLY.},label={lst:comp-mypy}]{listings/comparison/mypy-math-parser-analysis.txt}

Większość zgłoszonych błędów wynika z~dynamicznego charakteru biblioteki SLY: tokeny są definiowane jako zmienne klasowe bez jawnej deklaracji typu, a~dekorator~\verb|@_()| nie jest rozpoznawany przez analizator statyczny.
Ponadto konwencja definiowania wielu metod o~tej samej nazwie (\verb|expr|) dla alternatywnych produkcji jest traktowana jako błąd redefinicji.

Rysunek~\ref{fig:comp-sly-ide} przedstawia widok kodu SLY w~środowisku VS Code, gdzie widoczne są ostrzeżenia generowane przez wbudowany analizator statyczny.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/SlyMathParserInIDE}
    \caption{Ostrzeżenia IDE dla poprawnego kodu parsera SLY w~środowisku VS Code.}
    \label{fig:comp-sly-ide}
\end{figure}

\clearpage

\section{Podsumowanie analizy porównawczej}
\label{sec:comp-summary-sec}

Przeprowadzona analiza porównawcza pozwala na~weryfikację tezy postawionej w~rozdziale~\ref{ch:intro}.
W~odniesieniu do~pytań badawczych sformułowanych w~sekcji~\ref{sec:intro-thesis}, można sformułować następujące wnioski:

\begin{itemize}
    \item Faza parsowania systemu~\emph{ALPACA} osiąga wydajność porównywalną z~FastParse i~znacząco przewyższa bibliotekę SLY\@.
          Moduł leksykalizacji wymaga dalszej optymalizacji dla niektórych wzorców wyrażeń regularnych.

    \item Interfejs API oparty na~dopasowaniu wzorców Scali oferuje naturalne wyrażenie reguł gramatycznych przy zachowaniu pełnego bezpieczeństwa typów i~integracji z~IDE\@.

    \item System generuje komunikaty błędów zawierające kontekst syntaktyczny.
\end{itemize}

\subsection{Kierunki dalszych prac}
\label{subsec:comp-future}

Na~podstawie przeprowadzonych badań zidentyfikowano następujące kierunki dalszego rozwoju systemu~\emph{ALPACA}:

\begin{itemize}
    \item Wprowadzenie dedykowanego mechanizmu pomijania białych znaków, analogicznego do~rozwiązania stosowanego w~bibliotece SLY, który eliminowałby narzut tokenizacji dla sekwencji spacji i~tabuladorów.

    \item Implementacja algorytmu LALR(1) w~celu redukcji rozmiaru tabel parsowania dla dużych gramatyk.

    \item Przeprowadzenie testów na~większej liczbie gramatyk reprezentujących rzeczywiste języki programowania (np.~podzbiór Scali, SQL).
\end{itemize}
