\chapter[Analiza porównawcza z istniejącymi rozwiązaniami]{Analiza porównawcza z~istniejącymi rozwiązaniami}
\label{ch:comp}


\section{Wprowadzenie do badań porównawczych}
\label{sec:comp-intro}

Weryfikacja empiryczna tezy pracy wymaga systematycznego porównania systemu~\emph{ALPACA} z~reprezentatywnymi rozwiązaniami istniejącymi na~rynku.
W~tym celu przeprowadzono serię testów wydajnościowych (ang.~\emph{benchmarks}), których metodologia, wyniki oraz interpretacja zostaną przedstawione w~niniejszym rozdziale.

Wybór narzędzi porównawczych wynikał z~analizy przeprowadzonej w~sekcji~\ref{sec:intro-review}.
Jako rozwiązania reprezentatywne dla głównych kategorii wybrano:

\begin{itemize}
    \item \textbf{SLY}~\cite{sly} --- bibliotekę dla języka Python, reprezentującą podejście oparte na~refleksji i~dynamicznym typowaniu (kategoria bibliotek w językach interpretowanych),
    \item \textbf{FastParse}~\cite{fastparse-docs} --- bibliotekę kombinatorów parserów dla Scali, reprezentującą nowoczesne podejście do~budowy parserów w~językach statycznie typowanych (kategoria kombinatorów parserów).
\end{itemize}

Wybór tych narzędzi uzasadniony jest ich reprezentatywnością dla różnych paradygmatów konstrukcji parserów oraz dostępnością dokumentacji i~aktywnym wsparciem społeczności.
Pominięto generatory kodu takie jak ANTLR ze~względu na~różnice w~architekturze (zewnętrzny krok generacji vs.~metaprogramowanie w~czasie kompilacji), które utrudniają bezpośrednie porównanie wydajności.


\section{Metodologia badań}
\label{sec:comp-methodology}

\subsection{Środowisko testowe}
\label{subsec:comp-env}

Wszystkie testy zostały przeprowadzone w~kontrolowanym środowisku o~następujących parametrach:

\begin{itemize}
    \item \textbf{Procesor:} Apple M4 Pro, 14 rdzeni
    \item \textbf{Pamięć RAM:} 48 GB
    \item \textbf{System operacyjny:} macOS Sequoia 15.6
    \item \textbf{JVM:} OpenJDK 21.0.8
    \item \textbf{Python:} 3.13.5
    \item \textbf{Scala:} 3.8.0-RC1
\end{itemize}

Przed każdym pomiarem wykonywano fazę rozgrzewki (ang.~\emph{warmup}) składającą się z~trzech iteracji, co~pozwalało na~optymalizację kodu przez kompilator JIT~\cite{lindholm2014java} oraz stabilizację pamięci podręcznej procesora.
Każdy test był powtarzany 10~razy, a~wyniki uśredniano w~celu redukcji wpływu losowych wahań wydajności.

\subsection{Charakterystyka danych testowych}
\label{subsec:comp-data}

Testy wydajnościowe przeprowadzono na~dwóch rodzajach gramatyk: prostej gramatyce wyrażeń arytmetycznych oraz gramatyce formatu JSON\@.
Dla każdej gramatyki przygotowano dwa typy danych wejściowych różniące się strukturą:

\subsubsection{Dane iteracyjne}
\label{subsubsec:comp-data-iter}

Dane iteracyjne charakteryzują się płaską strukturą składniową bez głębokiego zagnieżdżenia.
Dla wyrażeń arytmetycznych przyjęto formę ciągu operacji:

\lstinputlisting[language=terminal,caption={Struktura iteracyjnych danych testowych dla wyrażeń arytmetycznych},label={lst:comp-iter-math}]{listings/comparison/iterative-math-structure.txt}

Dla formatu JSON dane iteracyjne reprezentują tablicę obiektów o~stałej głębokości zagnieżdżenia:

\lstinputlisting[language=json,caption={Struktura iteracyjnych danych testowych dla JSON},label={lst:comp-iter-json}]{listings/comparison/iterative-json-structure.json}

\subsubsection{Dane rekurencyjne}
\label{subsubsec:comp-data-recur}

Dane rekurencyjne charakteryzują się głębokim zagnieżdżeniem struktur składniowych, co~stanowi wyzwanie dla parserów ze~względu na~wykorzystanie stosu wywołań.
Dla wyrażeń arytmetycznych przyjęto formę zagnieżdżonych nawiasów:

\lstinputlisting[language=terminal,caption={Struktura rekurencyjnych danych testowych dla wyrażeń arytmetycznych},label={lst:comp-recur-math}]{listings/comparison/recursive-math-structure.txt}

Dla formatu JSON dane rekurencyjne reprezentują głęboko zagnieżdżone obiekty:

\lstinputlisting[language=json,caption={Struktura rekurencyjnych danych testowych dla JSON},label={lst:comp-recur-json}]{listings/comparison/recursive-json-structure.json}

\subsection{Scenariusze testowe}
\label{subsec:comp-scenarios}

Pomiary przeprowadzono dla rozmiarów danych wejściowych: 100, 500, 1000 oraz 2000~elementów (linii lub obiektów w~przypadku JSON).

Dla każdego rozmiaru mierzono następujące metryki:

\begin{itemize}
    \item \textbf{Czas leksykalizacji} (ang.~\emph{lex time}) --- czas przekształcenia tekstu wejściowego w~strumień tokenów (dotyczy ALPACA i~SLY, które wyróżniają fazę leksykalizacji),
    \item \textbf{Czas parsowania} (ang.~\emph{parse time}) --- czas analizy składniowej strumienia tokenów,
    \item \textbf{Całkowity czas przetwarzania} (ang.~\emph{full parse time}) --- łączny czas leksykalizacji i~parsowania.
\end{itemize}

FastParse realizuje leksykalizację i~parsowanie w~jednym przebiegu, dlatego dla tej biblioteki mierzono wyłącznie całkowity czas przetwarzania.


\section{Implementacja parserów testowych}
\label{sec:comp-impl}

W~celu zapewnienia porównywalności wyników, dla każdego narzędzia zaimplementowano funkcjonalnie równoważne parsery wyrażeń arytmetycznych oraz formatu JSON\@.
Wszystkie implementacje realizują bezpośrednią ewaluację (obliczenie wartości wyrażenia) zamiast konstrukcji drzewa AST, co~eliminuje różnice wydajnościowe wynikające ze~strategii alokacji pamięci.

\subsection[Implementacja w ALPACA]{Implementacja w~ALPACA}
\label{subsec:comp-impl-alpaca}

Parser wyrażeń arytmetycznych w~systemie~\emph{ALPACA} wykorzystuje deklaratywny interfejs DSL oparty na~dopasowaniu wzorców:

\lstinputlisting[language=scala,caption={Parser wyrażeń arytmetycznych w~systemie ALPACA},label={lst:comp-alpaca-math},escapeinside={(*@}{@*)}]{listings/comparison/alpaca-math-parser.scala}

\subsection[Implementacja w SLY]{Implementacja w~SLY}
\label{subsec:comp-impl-sly}

Odpowiadająca implementacja w~bibliotece SLY wykorzystuje dekoratory i~refleksję nazw metod:

\lstinputlisting[language=python,caption={Parser wyrażeń arytmetycznych w~bibliotece SLY},label={lst:comp-sly-math}]{listings/comparison/sly-math-parser.py}

\subsection[Implementacja w FastParse]{Implementacja w~FastParse}
\label{subsec:comp-impl-fastparse}

FastParse realizuje parsowanie poprzez kompozycję funkcji parserowych:

\lstinputlisting[language=scala,caption={Parser wyrażeń arytmetycznych w~bibliotece FastParse},label={lst:comp-fastparse-math}]{listings/comparison/fastparse-math-parser.scala}

Charakterystyczną cechą FastParse jest brak wydzielonej fazy leksykalizacji --- tokenizacja i~parsowanie są realizowane w~jednym przebiegu poprzez kompozycję parserów elementarnych.


\section{Wyniki badań}
\label{sec:comp-results}

\subsection{Wyrażenia arytmetyczne --- dane iteracyjne}
\label{subsec:comp-res-iter-math}

Tabela~\ref{tab:comp-res-iter-math} przedstawia wyniki testów wydajnościowych dla wyrażeń arytmetycznych o~strukturze iteracyjnej.

\begin{table}[ht]
    \centering
    \begin{tabularx}{\textwidth}{l|*{3}{Y}|*{3}{Y}|Y}
        \toprule
        \multirow{2}{*}{\textbf{Rozmiar}} & \multicolumn{3}{c|}{\textbf{ALPACA}} & \multicolumn{3}{c|}{\textbf{SLY}} & \textbf{FastParse}                                               \\
                                          & Lex                                  & Parse                             & Razem              & Lex      & Parse     & Razem     & Razem    \\
        \midrule
        100                               & 16,85~ms                             & 8,49~ms                           & 16,48~ms           & 1,52~ms  & 6,69~ms   & 8,24~ms   & 6,13~ms  \\
        500                               & 41,94~ms                             & 17,63~ms                          & 30,07~ms           & 7,98~ms  & 31,18~ms  & 38,57~ms  & 14,13~ms \\
        1000                              & 40,58~ms                             & 10,95~ms                          & 77,24~ms           & 14,84~ms & 59,65~ms  & 76,50~ms  & 21,24~ms \\
        2000                              & 166,89~ms                            & 21,22~ms                          & 188,56~ms          & 30,61~ms & 124,52~ms & 156,70~ms & 7,73~ms  \\
        \bottomrule
    \end{tabularx}
    \caption{Wyniki testów wydajnościowych dla wyrażeń arytmetycznych (dane iteracyjne)}
    \label{tab:comp-res-iter-math}
\end{table}

\subsection{Wyrażenia arytmetyczne --- dane rekurencyjne}
\label{subsec:comp-res-recur-math}

Tabela~\ref{tab:comp-res-recur-math} przedstawia wyniki dla wyrażeń arytmetycznych o~strukturze rekurencyjnej (głębokie zagnieżdżenie nawiasów).

\begin{table}[ht]
    \centering
    \begin{tabularx}{\textwidth}{l|*{3}{Y}|*{3}{Y}|Y}
        \toprule
        \multirow{2}{*}{\textbf{Rozmiar}} & \multicolumn{3}{c|}{\textbf{ALPACA}} & \multicolumn{3}{c|}{\textbf{SLY}} & \textbf{FastParse}                                                                 \\
                                          & Lex                                  & Parse                             & Razem              & Lex      & Parse     & Razem     & Razem                      \\
        \midrule
        100                               & 3,55~ms                              & 1,70~ms                           & 4,96~ms            & 1,79~ms  & 7,27~ms   & 9,25~ms   & 3,10~ms                    \\
        500                               & 27,70~ms                             & 7,81~ms                           & 29,92~ms           & 10,45~ms & 35,30~ms  & 46,85~ms  & 4,56~ms                    \\
        1000                              & 63,79~ms                             & 12,94~ms                          & 80,08~ms           & 20,22~ms & 72,95~ms  & 96,95~ms  & 7,29~ms                    \\
        2000                              & 220,96~ms                            & 25,82~ms                          & 274,95~ms          & 43,06~ms & 150,68~ms & 194,77~ms & \emph{Stack\-Over\-flow} \\
        \bottomrule
    \end{tabularx}
    \caption{Wyniki testów wydajnościowych dla wyrażeń arytmetycznych (dane rekurencyjne)}
    \label{tab:comp-res-recur-math}
\end{table}

Wyniki ujawniają istotne ograniczenie biblioteki FastParse: dla danych rekurencyjnych o~głębokości przekraczającej 1000~poziomów zagnieżdżenia występuje błąd przepełnienia stosu (ang.~\emph{StackOverflowError}).
Jest to~konsekwencją architektury kombinatorów parserów, które realizują rekurencję poprzez stos wywołań JVM\@.

\subsection{Format JSON --- dane iteracyjne}
\label{subsec:comp-res-iter-json}

Tabela~\ref{tab:comp-res-iter-json} przedstawia wyniki dla formatu JSON o~strukturze iteracyjnej (tablica obiektów).

\begin{table}[ht]
    \centering
    \begin{tabularx}{\textwidth}{l|*{3}{Y}|*{3}{Y}|Y}
        \toprule
        \multirow{2}{*}{\textbf{Rozmiar}} & \multicolumn{3}{c|}{\textbf{ALPACA}} & \multicolumn{3}{c|}{\textbf{SLY}} & \textbf{FastParse}                                                \\
                                          & Lex                                  & Parse                             & Razem              & Lex       & Parse     & Razem     & Razem    \\
        \midrule
        100                               & 30,63~ms                             & 4,09~ms                           & 26,27~ms           & 7,22~ms   & 17,07~ms  & 24,88~ms  & 15,82~ms \\
        500                               & 144,00~ms                            & 20,55~ms                          & 164,02~ms          & 35,60~ms  & 87,15~ms  & 131,62~ms & 11,67~ms \\
        1000                              & 478,19~ms                            & 46,43~ms                          & 555,45~ms          & 75,34~ms  & 182,93~ms & 263,86~ms & 12,64~ms \\
        2000                              & 1,72~s                               & 117,50~ms                         & 1,58~s             & 151,88~ms & 374,71~ms & 550,08~ms & 16,58~ms \\
        \bottomrule
    \end{tabularx}
    \caption{Wyniki testów wydajnościowych dla formatu JSON (dane iteracyjne)}
    \label{tab:comp-res-iter-json}
\end{table}

\subsection{Format JSON --- dane rekurencyjne}
\label{subsec:comp-res-recur-json}

Tabela~\ref{tab:comp-res-recur-json} przedstawia wyniki dla formatu JSON o~strukturze rekurencyjnej (głęboko zagnieżdżone obiekty).

\begin{table}[ht]
    \centering
    \begin{tabularx}{\textwidth}{l|*{3}{Y}|*{3}{Y}|Y}
        \toprule
        \multirow{2}{*}{\textbf{Rozmiar}} & \multicolumn{3}{c|}{\textbf{ALPACA}} & \multicolumn{3}{c|}{\textbf{SLY}} & \textbf{FastParse}                                                 \\
                                          & Lex                                  & Parse                             & Razem              & Lex       & Parse     & Razem     & Razem     \\
        \midrule
        100                               & 44,96~ms                             & 4,33~ms                           & 49,44~ms           & 20,33~ms  & 17,77~ms  & 39,81~ms  & 3,47~ms   \\
        500                               & 2,99~s                               & 18,09~ms                          & 3,02~s             & 358,04~ms & 95,21~ms  & 459,70~ms & 15,19~ms  \\
        1000                              & 23,55~s                              & 37,51~ms                          & 23,52~s            & 1,36~s    & 189,58~ms & 1,58~s    & 86,38~ms  \\
        2000                              & ---                                  & ---                               & ---                & 5,26~s    & 385,47~ms & 5,79~s    & 346,44~ms \\
        \bottomrule
    \end{tabularx}
    \caption{Wyniki testów wydajnościowych dla formatu JSON (dane rekurencyjne)}
    \label{tab:comp-res-recur-json}
\end{table}

Dla przypadku 2000~elementów system~\emph{ALPACA} nie zakończył pomiaru w~akceptowalnym czasie (oznaczono jako~---).

Wyniki dla rekurencyjnych danych JSON ujawniają problem wydajnościowy w~module leksykalizacji systemu~\emph{ALPACA} dla danych o~wysokim stopniu zagnieżdżenia.
Czas leksykalizacji rośnie nieproporcjonalnie do~rozmiaru danych, co~wymaga dalszej analizy i~optymalizacji (sekcja~\ref{subsec:comp-conclusions}).


\section{Analiza wyników}
\label{sec:comp-analysis}

\subsection{Porównanie faz przetwarzania}
\label{subsec:comp-phases}

Analiza wyników ujawnia zróżnicowaną charakterystykę wydajnościową poszczególnych faz przetwarzania:

\subsubsection{Faza leksykalizacji}

Lekser biblioteki SLY wykazuje stabilną i~przewidywalną wydajność, charakteryzującą się liniową złożonością względem rozmiaru danych wejściowych.
Lekser systemu~\emph{ALPACA} osiąga porównywalną wydajność dla danych iteracyjnych, jednak wykazuje znaczący spadek wydajności dla danych rekurencyjnych JSON\@.

Przyczyną tego zachowania jest sposób obsługi białych znaków w~obu systemach.
W~danych testowych JSON każdy poziom zagnieżdżenia dodaje dwie spacje wcięcia.
Dla testu \texttt{recursive\_json\_2000} najbardziej zagnieżdżony obiekt jest wcięty za~pomocą 4000~spacji.
System~\emph{ALPACA} tokenizuje każdą sekwencję białych znaków jako osobny token typu \verb|Ignored|, co~wymaga dopasowania wzorca wyrażenia regularnego dla każdej spacji.

Biblioteka SLY stosuje odmienne podejście --- pomijanie ignorowanych znaków realizowane jest prostym warunkiem iteracyjnym:

\lstinputlisting[language=python,caption={Mechanizm pomijania białych znaków w~bibliotece SLY},label={lst:comp-sly-ignore}]{listings/comparison/sly-ignore-mechanism.py}

To podejście eliminuje narzut związany z~dopasowaniem wyrażeń regularnych dla białych znaków, co~tłumaczy znaczącą przewagę wydajnościową SLY w~fazie leksykalizacji dla danych o~dużym stopniu zagnieżdżenia.
Optymalizacja mechanizmu ignorowania znaków stanowi kierunek przyszłych prac opisanych w~sekcji~\ref{subsec:comp-future}.

\subsubsection{Faza parsowania}

Faza parsowania systemu~\emph{ALPACA} wykazuje stabilną wydajność, znacząco przewyższającą bibliotekę SLY dla wszystkich testowanych scenariuszy.
Różnica ta wynika z~różnic architektonicznych:

\begin{itemize}
    \item \textbf{ALPACA} wykorzystuje tabele parsowania LR(1) generowane w~czasie kompilacji, co~eliminuje narzut interpretacji w~czasie wykonania,
    \item \textbf{SLY} interpretuje reguły gramatyczne w~czasie wykonania z~wykorzystaniem refleksji Pythona, co~wprowadza znaczący narzut.
\end{itemize}

\subsection{Zachowanie przy głębokim zagnieżdżeniu}
\label{subsec:comp-nesting}

Testy z~danymi rekurencyjnymi ujawniły istotne różnice w~obsłudze głęboko zagnieżdżonych struktur:

\begin{itemize}
    \item \textbf{FastParse} --- przepełnienie stosu dla głębokości zagnieżdżenia przekraczającej 1000--2000~poziomów, co~jest konsekwencją rekursywnej natury kombinatorów parserów,
    \item \textbf{ALPACA} --- stabilne działanie parsera niezależnie od~głębokości zagnieżdżenia dzięki wykorzystaniu automatu ze~stosem zamiast rekurencji,
    \item \textbf{SLY} --- stabilne działanie dla wszystkich testowanych głębokości, analogicznie do~ALPACA\@.
\end{itemize}

Obserwacja ta potwierdza przewagę parserów LR nad kombinatorami parserów w~scenariuszach wymagających obsługi głęboko zagnieżdżonych struktur.

\subsection{Wnioski}
\label{subsec:comp-conclusions}

Przeprowadzone eksperymenty pozwalają na sformułowanie następujących wniosków dotyczących wydajności systemu \emph{ALPACA}.

Zalety systemu:
\begin{itemize}
    \item Faza parsowania systemu \emph{ALPACA} charakteryzuje się stabilną i przewidywalną wydajnością, przewyższającą bibliotekę \emph{SLY} we wszystkich analizowanych scenariuszach testowych.
    \item Zastosowanie parsera klasy LR(1) eliminuje ograniczenia wynikające z rozmiaru stosu wywołań, umożliwiając poprawne przetwarzanie struktur o dowolnej głębokości zagnieżdżenia.
    \item Liniowa złożoność czasowa procesu parsowania względem liczby tokenów zapewnia deterministyczne i przewidywalne czasy przetwarzania danych wejściowych.
\end{itemize}

\paragraph{Obszary wymagające optymalizacji:}
Mechanizm obsługi znaków ignorowanych wykazuje obniżoną wydajność w przypadku danych wejściowych charakteryzujących się dużym stopniem wcięcia. Wynika to z faktu, że każda sekwencja znaków białych jest tokenizowana jako osobna jednostka, co prowadzi do zwiększonego narzutu obliczeniowego.


\section{Porównanie interfejsów programistycznych}
\label{sec:comp-api}

Oprócz wydajności, istotnym kryterium oceny narzędzi jest jakość interfejsu programistycznego (API).
Tabela~\ref{tab:comp-summary} zestawia kluczowe aspekty interfejsów porównywanych narzędzi.

\begin{table}[ht]
    \centering
    \begin{tabularx}{\textwidth}{L|YYY}
        \toprule
        \textbf{Kryterium}               & \textbf{ALPACA} & \textbf{SLY} & \textbf{FastParse} \\
        \midrule
        Wydajność parsowania             & wysoka          & niska        & wysoka             \\
        \hline
        Wydajność leksykalizacji         & średnia*        & wysoka       & nie dotyczy        \\
        \hline
        Obsługa głębokiego zagnieżdżenia & pełna           & pełna        & ograniczona        \\
        \hline
        Bezpieczeństwo typów             & pełne           & brak         & pełne              \\
        \hline
        Integracja IDE                   & pełna           & ograniczona  & pełna              \\
        \hline
        Diagnostyka błędów               & dobra           & średnia      & dobra              \\
        \bottomrule
    \end{tabularx}
    \caption{Podsumowanie analizy porównawczej (* wymaga optymalizacji mechanizmu ignorowania białych znaków)}
    \label{tab:comp-summary}
\end{table}

\subsection{Bezpieczeństwo typów}
\label{subsec:comp-api-types}

System~\emph{ALPACA} oferuje pełne bezpieczeństwo typów na~poziomie kompilacji dzięki wykorzystaniu typów rafinowanych (sekcja~\ref{subsec:impl-lexer-refinement}).
Każdy token i~wynik parsowania posiada precyzyjny typ znany kompilatorowi, co~umożliwia wykrywanie błędów przed uruchomieniem programu.

W~przeciwieństwie do~tego, biblioteka SLY wykorzystuje dynamiczne typowanie Pythona, co~oznacza, że~błędy typów są wykrywane dopiero w~czasie wykonania.
Fragment kodu~\ref{lst:comp-sly-type-error} ilustruje sytuację, w~której błąd typowania w~akcji semantycznej zostanie wykryty dopiero podczas parsowania konkretnego wejścia:

\lstinputlisting[language=python,caption={Błąd typowania wykrywany dopiero w~czasie wykonania (SLY)},label={lst:comp-sly-type-error}]{listings/comparison/sly-type-error.py}

\subsection[Integracja ze środowiskiem IDE]{Integracja ze~środowiskiem IDE}
\label{subsec:comp-api-ide}

System~\emph{ALPACA} oferuje pełną integrację ze~standardowymi narzędziami IDE dla języka Scala (IntelliJ IDEA, Metals) bez konieczności instalacji dedykowanych wtyczek.
Funkcjonalności takie jak:

\begin{itemize}
    \item automatyczne uzupełnianie nazw tokenów,
    \item nawigacja do~definicji (\emph{go-to-definition}),
    \item prezentacja typów przy najechaniu kursorem,
    \item wykrywanie błędów w~czasie rzeczywistym
\end{itemize}

są dostępne natywnie dzięki wykorzystaniu systemu typów Scali.

Biblioteka SLY, ze~względu na~wykorzystanie refleksji i~niestandardowych konwencji (nazwy metod jako produkcje, dekoratory~\verb|@_()|), oferuje ograniczone wsparcie IDE\@.
Analizatory statyczne, takie jak mypy, generują liczne błędy dla poprawnego kodu SLY, co~ilustruje fragment~\ref{lst:comp-mypy}:

\lstinputlisting[language=terminal,caption={Wynik analizy statycznej mypy dla parsera SLY},label={lst:comp-mypy}]{listings/comparison/mypy-math-parser-analysis.txt}

Większość zgłoszonych błędów wynika z~dynamicznego charakteru biblioteki SLY: tokeny są definiowane jako zmienne klasowe bez jawnej deklaracji typu, a~dekorator~\verb|@_()| nie jest rozpoznawany przez analizator statyczny.
Ponadto konwencja definiowania wielu metod o~tej samej nazwie (\verb|expr|) dla alternatywnych produkcji jest traktowana jako błąd redefinicji.

Rysunek~\ref{fig:comp-sly-ide} przedstawia widok kodu SLY w~środowisku VS Code, gdzie widoczne są ostrzeżenia generowane przez wbudowany analizator statyczny:

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.9\textwidth]{figures/SlyMathParserInIDE}
    \caption{Ostrzeżenia IDE dla poprawnego kodu parsera SLY w~środowisku VS Code}
    \label{fig:comp-sly-ide}
\end{figure}

\clearpage

\section{Podsumowanie analizy porównawczej}
\label{sec:comp-summary-sec}

Przeprowadzona analiza porównawcza pozwala na~weryfikację tezy postawionej w~rozdziale~\ref{ch:intro}.
W~odniesieniu do~pytań badawczych sformułowanych w~sekcji~\ref{sec:intro-thesis}:

\begin{itemize}
    \item Faza parsowania systemu~\emph{ALPACA} osiąga wydajność porównywalną z~FastParse i~znacząco przewyższa bibliotekę SLY\@.
          Moduł leksykalizacji wymaga dalszej optymalizacji dla niektórych wzorców wyrażeń regularnych.

    \item Interfejs API oparty na~dopasowaniu wzorców Scali oferuje naturalne wyrażenie reguł gramatycznych przy zachowaniu pełnego bezpieczeństwa typów i~integracji z~IDE\@.

    \item System generuje komunikaty błędów zawierające kontekst syntaktyczny.
\end{itemize}

\subsection{Kierunki dalszych prac}
\label{subsec:comp-future}

Na~podstawie przeprowadzonych badań zidentyfikowano następujące kierunki dalszego rozwoju systemu~\emph{ALPACA}:

\begin{itemize}
    \item Wprowadzenie dedykowanego mechanizmu pomijania białych znaków, analogicznego do~rozwiązania stosowanego w~bibliotece SLY, który eliminowałby narzut tokenizacji dla sekwencji spacji i~tabulatorów,

    \item Implementacja algorytmu LALR(1) w~celu redukcji rozmiaru tabel parsowania dla dużych gramatyk,

    \item Przeprowadzenie testów na~większej liczbie gramatyk reprezentujących rzeczywiste języki programowania (np.~podzbiór Scali, SQL).
\end{itemize}
