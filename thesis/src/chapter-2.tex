\chapter{Zakres funkcjonalności}
\label{ch:zakres-funkcjonalnosci}


\section{Wymagania funkcjonalne}
\label{sec:wymagania-funkcjonalne}

\begin{itemize}

    \item 1. Definicja parsera i gramatyki
    \begin{itemize}
        \item Możliwość definiowania reguł gramatycznych za pomocą czystego języka Scala z obsługą wyrażeń regularnych i hierarchii reguł (bez DSL).
        \item Generowanie drzewa składniowego: Automatyczne tworzenie struktury AST (Abstract Syntax Tree) z formatu EBNF\@.
        \item Możliwość definiowania reguł rekurencyjnych.
        \item Precyzyjne raportowanie błędów z lokalizacją w źródle, sugestiami napraw i trybem odzyskiwania (np.\ pomijanie błędnych tokenów).
        \item Obsługa precedencji i asocjacji operatorów.
    \end{itemize}

    \item \item 2. Integracja z narzędziami developerskimi
    \begin{itemize}
        \item Obsługa podświetlania składni, autouzupełniania i debugowania w środowiskach takich jak IntelliJ lub VS Code.
    \end{itemize}

    \item 3. Optymalizacje wydajnościowe
    \begin{itemize}
        \item Obsługa dużych plików poprzez przetwarzanie danych strumieniowo.
        \item Przechowywanie skompilowanych gramatyk w pamięci w celu przyspieszenia powtarzalnych operacji.
    \end{itemize}

    \item 4. Rozszerzalność
    \begin{itemize}
        \item Możliwość dołączania funkcji wykonywanych podczas parsowania (np.\ walidacja kontekstowa).
        \item Podział implementacji na niezależne komponenty (np.\ lexer, parser).
        \item Mechanizmy transformacji AST: struktury TreeMap oraz TreeTraverser.
    \end{itemize}

    \item
\end{itemize}


\section{Wymagania niefunkcjonalne}
\label{sec:wymagania-niefunkcjonalne}

\begin{itemize}

    \item \item 1. Wydajność
    \begin{itemize}
        \item Czas parsowania zbliżony lub lepszy od czasów narzędzi \textit{FastParse} i \textit{Sly}.
        \item Zużycie pamięci stałe, niezależne od rozmiaru parsowanego pliku.
    \end{itemize}

    \item 2. Skalowalność
    \begin{itemize}
        \item Obsługa dużych gramatyk.
        \item Modularność.
    \end{itemize}

    \item 3. Niezawodność
    \begin{itemize}
        \item Testy regresyjne: Pokrycie kodu testami ≥ 90\%, z automatycznym uruchamianiem po każdej zmianie.
    \end{itemize}

    \item 4. Kompatybilność
    \begin{itemize}
        \item Wsparcie dla IntelliJ i VS Code (Metals).
        \item Systemy operacyjne: Działanie na Windows, Linux i macOS bez modyfikacji kodu.
    \end{itemize}

    \item 5. Użyteczność
    \begin{itemize}
        \item Obszerna dokumentacja z przykładami.
        \item Narzędzia diagnostyczne, np.\ wizualizacja drzewa AST\@.
        \item Weryfikacja poprawności gramatyk na poziomie typów.
    \end{itemize}

\end{itemize}


\section{Charakterystyka użytkowników}
\label{sec:charakterystyka-uzytkownikow}

\textit{Alpaca} jest skierowana do wszystkich zajmujących się aalizą składniową, lub gramatyczną, oraz tworzeniem języków formalnych, w szczególności języków programowania.
W zależności od kontekstu można wyróżnić następujące grupy docelowe:

\begin{itemize}
    \item \textbf{Programiści tworzący języki domenowe (DSL):}
    Specjaliści projektujący rozwiązania specyficzne dla danego problemu (np.
    konfiguratory\footnote{Konfigurator to specjalizowany język lub narzędzie umożliwiające deklaratywne definiowanie zachowania systemu lub aplikacji, najczęściej poprzez pliki konfiguracyjne. Przykłady to \texttt{docker-compose.yml} czy pliki konfiguracji serwisów CI/CD.},
    silniki reguł\footnote{Silnik reguł (ang. \textit{rule engine}) to system przetwarzający zbiory warunków logicznych i wyzwalający odpowiednie akcje w oparciu o zdefiniowane reguły. Typowym zastosowaniem jest automatyzacja procesów biznesowych. Przykłady: Drools, CLIPS.},
    ), dla których kluczowa jest elastyczność definiowania składni. Dla tej grupy istotna jest także niezawodność oraz wydajność procesu parsowania.

    \item \textbf{Studenci kierunków technicznych:}
    Osoby uczące się podstaw teorii kompilacji, które korzystają z narzędzi typu lekser/parser w celach dydaktycznych.
    Dla tej grupy kluczowe znaczenie ma intuicyjny interfejs programistyczny (API), rozbudowana dokumentacja oraz możliwość szybkiego uruchomienia przykładów bez konieczności ręcznej konfiguracji środowiska.

    \item \textbf{Nauczyciele akademiccy i prowadzący zajęcia laboratoryjne:}
    Osoby przygotowujące kursy dotyczące języków programowania, parserów, automatów i kompilatorów.
    \textit{Alpaca} może służyć jako narzędzie wspierające zajęcia, umożliwiające praktyczną demonstrację działania gramatyk oraz parserów w sposób prostszy i szybszy niż za pomocą niskopoziomowych narzędzi, takich jak Lex i Yacc.

    \item \textbf{Entuzjaści języków programowania i narzędzi deweloperskich:}
    Osoby zainteresowane eksperymentowaniem z nowymi technologiami, tworzeniem i rozwojem własnych języków lub eksploracją działania analizatorów leksykalnych i składniowych.
    Ta grupa użytkowników ceni sobie możliwość rozszerzania i dostosowywania narzędzia do własnych potrzeb.
\end{itemize}

Uwzględnienie potrzeb i oczekiwań powyższych grup użytkowników stanowiło główny cel projektowania architektury systemu oraz definiowania jego funkcjonalności.

\section{Scenariusze użytkowania i testowania}
\label{sec:scenariusze-uzytkowania}

Poniższe scenariusze prezentują typowe przypadki użycia biblioteki \textit{Alpaca}, wraz z towarzyszącymi im kryteriami poprawności oraz celami testowymi.

\subsection*{Scenariusz 1: Definicja parsera}

\textbf{Cel:} Zdefiniowanie parsera dla prostego języka wyrażeń arytmetycznych.\\

\textbf{Kroki:}
\begin{enumerate}
    \item Użytkownik definiuje leksemy (np. liczby, operatory arytmetyczne).
    \item Tworzy nieterminale (np. \texttt{wyrazenie}, \texttt{iloczyn}) oraz odpowiadające im reguły gramatyczne (np. \texttt{potega = podstawa '**' wykladnik}).
    \item Deklaruje funkcje ewaluacyjne dla odpowiednich produkcji (np. \texttt{pow(base, exponent)} dla potęgowania).
    \item Uruchamia parser dla przykładowego ciągu wejściowego.
\end{enumerate}

\textbf{Oczekiwany rezultat:} Parser generuje poprawne drzewo składniowe (AST) oraz zwraca wynik zgodny z semantyką definiowanej gramatyki.\\

\textbf{Przykład testowy:} \texttt{parse("2 + 2")} zwraca wartość \texttt{4} oraz drzewo składniowe reprezentujące operację dodawania z dwoma operandami liczbowymi.

\subsection*{Scenariusz 2: Obsługa błędów składniowych}

\textbf{Cel:} Weryfikacja zachowania parsera w przypadku niepoprawnych danych wejściowych.\\

\textbf{Kroki:}
\begin{enumerate}
    \item Użytkownik korzysta z przykładowej definicji parsera udostępnionej w dokumentacji lub przez prowadzącego.
    \item Parser uruchamiany jest na niepoprawnym ciągu wejściowym (np. brakujący nawias zamykający).
    \item System zwraca komunikat o błędzie z podaniem lokalizacji problemu oraz jego opisu.
\end{enumerate}

\textbf{Oczekiwany rezultat:} System zgłasza czytelny komunikat błędu zawierający informacje o miejscu i charakterze błędu składniowego.

\subsection*{Scenariusz 3: Weryfikacja deterministyczności gramatyki}

\textbf{Cel:} Ocena, czy zadana gramatyka jest deterministyczna i wolna od niejednoznaczności.\\

\textbf{Kroki:}
\begin{enumerate}
    \item Użytkownik konstruuje złożoną gramatykę zawierającą alternatywne reguły.
    \item Parser analizuje zachowanie dla potencjalnie niejednoznacznych ciągów wejściowych.
\end{enumerate}

\textbf{Oczekiwany rezultat:} System wykrywa i zgłasza potencjalne konflikty składniowe, informując o możliwej niejednoznaczności gramatyki.

\subsection*{Scenariusz 4: Testowanie wydajności dla dużych wejść}

\textbf{Cel:} Pomiar wydajności działania parsera w przypadku dużych danych wejściowych.\\

\textbf{Kroki:}
\begin{enumerate}
    \item Parser uruchamiany jest na ciągu wejściowym o rozmiarze kilkunastu megabajtów.
    \item Rejestrowany jest czas działania oraz poziom wykorzystania zasobów systemowych (pamięć operacyjna, CPU).
\end{enumerate}

\textbf{Oczekiwany rezultat:} Parser przetwarza dane w akceptowalnym czasie, nie generując błędów oraz nie przekraczając założonego limitu zużycia pamięci.
