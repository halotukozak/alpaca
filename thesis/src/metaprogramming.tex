\chapter[Metaprogramowanie w Scali 3]{Metaprogramowanie w~Scali~3}
\label{ch:metaprogramowanie-w-scali-3}


\section{Wprowadzenie}\label{sec:wprowadzenie}
Scala~3, znana również jako Dotty, wprowadza całkowicie przeprojektowany system metaprogramowania, stanowiący fundamentalną zmianę w~stosunku do eksperymentalnych makr dostępnych w~Scali~2~\cite{scala3-dropped-scala2-macros,scala3-metaprogramming}.
Metaprogramowanie w~Scali~3 zostało zaprojektowane z~naciskiem na bezpieczeństwo typów, przenośność oraz skalowalność, umożliwiając twórcom oprogramowania generowanie i~analizowanie kodu w~czasie kompilacji przy zachowaniu pełnej ekspresywności języka~\cite{stucki2024infoscience,stucki2020inlining}.
W~przeciwieństwie do poprzedniego systemu, który eksponował wewnętrzne mechanizmy kompilatora i~był źródłem problemów z~kompatybilnością między wersjami~\cite{stucki2020thesis}, nowy system metaprogramowania jest zaprojektowany jako stabilny i~przenośny interfejs programistyczny.
Podstawą teoretyczną systemu metaprogramowania w~Scali~3 jest programowanie wieloetapowe (ang.~\emph{multi-stage programming}), paradygmat pozwalający na odróżnienie różnych etapów wykonania programu~\cite{scala3-staging,stucki2020thesis}.
W~tym modelu kod może być wykonywany w~różnych fazach: w~czasie kompilacji (ang.~\emph{compile-time}) lub w~czasie wykonania (ang.~\emph{runtime})~\cite{scala3-staging}.

\subsection[Quotes i Splices]{Quotes i~Splices}\label{subsec:cytaty-i-wstawki}
Kluczowymi koncepcjami w~systemie metaprogramowania Scali~3 są \emph{quotes} i~\emph{splices}~\cite{stucki2018unification,stucki2021multistage}.
\emph{Quotes}, oznaczane jako \verb|'{...}|, służą do opóźnienia wykonania kodu i~traktowania go jako danych~\cite{scala3-reflection}.
\emph{Splices}, oznaczane jako \verb|${...}|, pozwalają na ocenę wyrażenia generującego kod i~wstawienie wyniku do otaczającego kontekstu~\cite{scala3-reflection,scala3-guides-quotes}.

Formalna semantyka tych konstrukcji została przedstawiona w~pracy Stuckiego, Brachthäusera i~Odersky'ego~\cite{stucki2021multistage}, gdzie \emph{quotes} i~\emph{splices} są traktowane jako prymitywne formy w~typowanych drzewach składniowych (ang.~\emph{typed abstract syntax trees}).
Autorzy dowodzą, że system zachowuje bezpieczeństwo typów oraz higieniczność, zapewniając, że wygenerowany kod nie może przypadkowo powiązać identyfikatorów z~niewłaściwymi zmiennymi~\cite{stucki2021multistage}.

\subsection{Bezpieczeństwo międzyetapowe}\label{subsec:bezpieczenstwo-miedzyetapowe}
Scala~3 gwarantuje bezpieczeństwo międzyetapowe (ang.~\emph{cross-stage safety}) poprzez sprawdzanie poziomów etapowania w~czasie kompilacji~\cite{stucki2020thesis,stucki2021multistage}.
Zmienne lokalne mogą być używane tylko na tym samym poziomie etapowania, na którym zostały zdefiniowane, co zapobiega dostępowi do zmiennych, które jeszcze nie istnieją lub już nie są dostępne~\cite{stucki2020thesis}.

System również zapewnia, że typy generyczne używane w~wyższym poziomie etapowania niż ich definicja wymagają instancji klasy typu \verb|Type[T]|, która niesie reprezentację typu niepoddaną wymazywaniu (ang.~\emph{type erasure})~\cite{stucki2020thesis}.
To podejście rozwiązuje problem wymazywania typów generycznych w~JVM, zachowując informację o~typach potrzebną w~kolejnych etapach kompilacji.


\section[Mechanizmy metaprogramowania w Scali 3]{Mechanizmy metaprogramowania w~Scali~3}\label{sec:mechanizmy-metaprogramowania-w-scali-3}

Przedstawione powyżej podstawy teoretyczne znajdują bezpośrednie zastosowanie w~praktycznych mechanizmach metaprogramowania oferowanych przez język Scala~3, które zostaną omówione w~niniejszej sekcji.

\subsection{Definicje inline}\label{subsec:definicje-inline}
Najprostszym narzędziem metaprogramowania jest modyfikator \verb|inline|~\cite{stucki2020semantics-preserving}.
Gwarantuje on, że wywołanie oznaczonej nim metody lub wartości zostanie w~całości wstawione w~miejscu wywołania (ang.~\textit{inlining}) podczas kompilacji.
Jest to instrukcja dla kompilatora, a~nie tylko sugestia, jak w~niektórych innych językach~\cite{lilis2019survey}.

\subsection{Makra oparte na wyrażeniach}\label{subsec:makra-oparte-na-wyrazeniach}
Makra w~Scali~3 są zdefiniowane jako metody \verb|inline| zawierające \emph{splice} najwyższego poziomu (ang.~\emph{top-level splice})~\cite{scala3-reference-macros,scala3-guides-macros}, czyli taki, który nie jest zagnieżdżony w~żadnym \emph{Quotes} i~jest wykonywany w~czasie kompilacji~\cite{scala3-staging,scala3-reference-macros}.

Typ \texttt{Expr[T]} reprezentuje wyrażenie Scali o~typie \texttt{T} jako typowane drzewo składniowe~\cite{scala3-reflection,scala3-guides-macros}.
Makra manipulują wartościami typu \texttt{Expr[T]}, transformując je lub generując nowe wyrażenia~\cite{scala3-guides-macros}.
Ta reprezentacja gwarantuje bezpieczeństwo typów na poziomie języka metaprogramowania~\cite{scala3-reflection}.

\subsection{Dopasowanie wzorców kodu}\label{subsec:dopasowanie-wzorcow-kodu}
Scala~3 wspiera analizę kodu poprzez dopasowanie wzorców w~cytatach kodu (ang.~\emph{quote pattern matching})~\cite{stucki2020thesis,stucki2021multistage}.
Mechanizm ten pozwala na dekonstrukcję kawałków kodu i~ekstrakcję podwyrażeń~\cite{stucki2021multistage}.

Stucki, Brachthäuser i~Odersky~\cite{stucki2021multistage} wprowadzają wzorce wiążące (ang.~\emph{bind patterns}) postaci \verb|$x| oraz wzorce HOAS (ang.~\emph{Higher-Order Abstract Syntax}) postaci \verb|$f(y)|, które pozwalają na ekstrakcję podwyrażeń potencjalnie zawierających zmienne z~zewnętrznego kontekstu.
System gwarantuje, że ekstrahowane wyrażenia są zamknięte względem definicji wewnątrz wzorca, zapobiegając wyciekom zakresu.

\subsection{Refleksja TASTy}\label{subsec:refleksja-tasty}
Dla przypadków wymagających głębszej analizy kodu, Scala~3 oferuje API refleksji TASTy~\cite{scala3-reflection,scala3-guides-reflection}.
TASTy jest binarnym formatem serializacji typowanych drzew składniowych używanym przez kompilator Scali~3~\cite{stucki2020thesis}.

API refleksji dostarcza szczegółowy widok na strukturę kodu, włączając typy, symbole oraz pozycje w~kodzie źródłowym.
Jest dostępne poprzez obiekt \texttt{reflect} zdefiniowany w~typie \texttt{Quotes}, który jest przekazywany kontekstualnie do makr~\cite{scala3-reflection,scala3-guides-reflection}.

