\chapter{Metaprogramowanie w Scali 3}
\label{ch:metaprogramowanie-w-scali-3}


\section{Wprowadzenie}\label{sec:wprowadzenie}
Scala 3, znana również jako Dotty, wprowadza całkowicie przeprojektowany system metaprogramowania, stanowiący fundamentalną zmianę w stosunku do eksperymentalnych makr dostępnych w Scali~2\cite{scala3-dropped-scala2-macros,scala3-metaprogramming}.

Metaprogramowanie w Scali 3 zostało zaprojektowane z naciskiem na bezpieczeństwo typów, przenośność oraz skalowalność, oferując programistom możliwość generowania i analizowania kodu w czasie kompilacji przy zachowaniu pełnej ekspresywności języka\cite{stucki2024infoscience,stucki2020inlining}.
W przeciwieństwie do poprzedniego systemu, który eksponował wewnętrzne mechanizmy kompilatora i był źródłem problemów z kompatybilnością między wersjami\cite{stucki2020thesis}, nowy system metaprogramowania jest zaprojektowany jako stabilny i przenośny interfejs programistyczny.
Podstawą teoretyczną systemu metaprogramowania w Scali 3 jest programowanie wieloetapowe (ang. \textit{multi-stage programming}), paradygmat pozwalający na odróżnienie różnych etapów wykonania programu\cite{scala3-staging,stucki2020thesis}.
W tym modelu kod może być wykonywany w różnych fazach: w czasie kompilacji (ang. \textit{compile-time}) lub w czasie wykonania (ang. \textit{runtime})\cite{scala3-staging}.

\subsection{Quotes i Splices}\label{subsec:cytaty-i-wstawki}
Kluczowymi koncepcjami w systemie metaprogramowania Scali 3 są \textit{quotes} i \textit{splices}\cite{stucki2018unification,stucki2021multistage}.
\textit{Quotes}, oznaczane jako \verb|'{...}|, służą do opóźnienia wykonania kodu i traktowania go jako danych\cite{scala3-reflection}.
\textit{Splices}, oznaczane jako \verb|${...}|, pozwalają na ocenę wyrażenia generującego kod i wstawienie wyniku do otaczającego kontekstu\cite{scala3-reflection,scala3-guides-quotes}.

Formalna semantyka tych konstrukcji została przedstawiona w pracy Stuckiego, Brachthäusera i Odersky'ego\cite{stucki2021multistage}, gdzie \textit{quotes} i \textit{splices} są traktowane jako prymitywne formy w typowanych drzewach składniowych (ang. \textit{typed abstract syntax trees)}.
Autorzy dowodzą, że system zachowuje bezpieczeństwo typów oraz higieniczność, zapewniając, że wygenerowany kod nie może przypadkowo powiązać identyfikatorów z niewłaściwymi zmiennymi\cite{stucki2021multistage}.

\subsection{Bezpieczeństwo międzyetapowe}\label{subsec:bezpieczenstwo-miedzyetapowe}
Scala 3 gwarantuje bezpieczeństwo międzyetapowe (ang. \textit{cross-stage safety}) poprzez sprawdzanie poziomów etapowania w czasie kompilacji\cite{stucki2020thesis,stucki2021multistage}.
Zmienne lokalne mogą być używane tylko na tym samym poziomie etapowania, na którym zostały zdefiniowane, co zapobiega dostępowi do zmiennych, które jeszcze nie istnieją lub już nie są dostępne\cite{stucki2020thesis}.

System również zapewnia, że typy generyczne używane w wyższym poziomie etapowania niż ich definicja wymagają instancji klasy typu \verb|Type[T]|, która niesie reprezentację typu niepoddaną wymazywaniu (ang. \textit{type erasure})\cite{stucki2020thesis}.
To podejście rozwiązuje problem wymazywania typów generycznych w~JVM, zachowując informację o typach potrzebną w kolejnych etapach kompilacji.


\section{Mechanizmy metaprogramowania w Scali 3}\label{sec:mechanizmy-metaprogramowania-w-scali-3}

\subsection{Definicje inline}\label{subsec:definicje-inline}
Najprostszym narzędziem metaprogramowania jest modyfikator \verb|inline|.
Gwarantuje on, że wywołanie oznaczonej nim metody lub wartości zostanie w całości \textbf{wstawione w miejscu wywołania} (ang. \textit{inlining}) podczas kompilacji.
Jest to polecenie dla kompilatora, a nie tylko sugestia, jak w niektórych innych językach.

\subsection{Makra oparte na wyrażeniach}\label{subsec:makra-oparte-na-wyrazeniach}
Makra w Scali 3 są zdefiniowane jako metody \verb|inline| zawierające \textit{splice} najwyższego poziomu (ang. \textit{top-level splice})\cite{scala3-reference-macros,scala3-guides-macros}, czyli taki, który nie jest zagnieżdżony w żadnym \textit{Quotes} i jest wykonywany w czasie kompilacji\cite{scala3-staging,scala3-reference-macros}.

Typ \texttt{Expr[T]} reprezentuje wyrażenie Scali o typie \texttt{T} jako typowane drzewo składniowe\cite{scala3-reflection,scala3-guides-macros}.
Makra manipulują wartościami typu \texttt{Expr[T]}, transformując je lub generując nowe wyrażenia\cite{scala3-guides-macros}.
Ta reprezentacja gwarantuje bezpieczeństwo typów na poziomie języka metaprogramowania\cite{scala3-reflection}.

\subsection{Dopasowanie wzorców kodu}\label{subsec:dopasowanie-wzorcow-kodu}
Scala 3 wspiera analizę kodu poprzez dopasowanie wzorców w \textit{quotes} (ang. \textit{quote pattern matching})\cite{stucki2020thesis,stucki2021multistage}.
Mechanizm ten pozwala na dekonstrukcję kawałków kodu i ekstrakcję podwyrażeń\cite{stucki2021multistage}.

Stucki, Brachthäuser i Odersky\cite{stucki2021multistage} wprowadzają wzorce wiążące (ang. \textit{bind patterns}) postaci \verb|$x| oraz wzorce HOAS (ang. \textit{Higher-Order Abstract Syntax}) postaci \verb|$f(y)|, które pozwalają na ekstrakcję podwyrażeń potencjalnie zawierających zmienne z zewnętrznego kontekstu.
System gwarantuje, że ekstrahowane wyrażenia są zamknięte względem definicji wewnątrz wzorca, zapobiegając wyciekom zakresu.

\subsection{Refleksja TASTy}\label{subsec:refleksja-tasty}
Dla przypadków wymagających głębszej analizy kodu, Scala 3 oferuje API refleksji TASTy\cite{scala3-reflection,scala3-guides-reflection}.
TASTy jest binarnym formatem serializacji typowanych drzew składniowych używanym przez kompilator Scali 3\cite{stucki2020thesis}.

API refleksji dostarcza szczegółowy widok na strukturę kodu, włączając typy, symbole oraz pozycje w kodzie źródłowym.
Jest dostępne poprzez obiekt \texttt{reflect} zdefiniowany w typie \texttt{Quotes}, który jest przekazywany kontekstualnie do makr\cite{scala3-reflection,scala3-guides-reflection}.

