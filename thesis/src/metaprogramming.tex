\chapter{Metaprogramowanie w Scali 3}\label{ch:metaprogramowanie-w-scali-3}


\section{Wprowadzenie}\label{sec:wprowadzenie}
Scala 3, znana również jako Dotty, wprowadza całkowicie przeprojektowany system metaprogramowania, stanowiący fundamentalną zmianę w stosunku do eksperymentalnych makr dostępnych w Scali~2\cite{scala3-dropped-scala2-macros,scala3-metaprogramming}.

Metaprogramowanie w Scali 3 zostało zaprojektowane z naciskiem na bezpieczeństwo typów, przenośność oraz skalowalność, oferując programistom możliwość generowania i analizowania kodu w czasie kompilacji przy zachowaniu pełnej ekspresywności języka\cite{stucki2024infoscience,stucki2020inlining}.
W przeciwieństwie do poprzedniego systemu, który eksponował wewnętrzne mechanizmy kompilatora i był źródłem problemów z kompatybilnością między wersjami\cite{stucki2020thesis}, nowy system metaprogramowania jest zaprojektowany jako stabilny i przenośny interfejs programistyczny.
Podstawą teoretyczną systemu metaprogramowania w Scali 3 jest programowanie wieloetapowe (multi-stage programming), paradygmat pozwalający na odróżnienie różnych etapów wykonania programu\cite{scala3-staging,stucki2020thesis}.
W tym modelu kod może być wykonywany w różnych fazach: w czasie kompilacji (compile-time), w czasie wykonania (runtime)\cite{scala3-staging}.

\subsection{Quotes i splices}\label{subsec:cytaty-i-wstawki}
Kluczowymi koncepcjami w systemie metaprogramowania Scali 3 są quotes i splices\cite{stucki2018unification,stucki2021multistage}.
Quotes, oznaczane jako \verb|'{...}|, służą do opóźnienia wykonania kodu i traktowania go jako danych\cite{scala3-reflection,epfl-dotty-reflection}.
Splices, oznaczane jako \verb|${...}|, pozwalają na ocenę wyrażenia generującego kod i wstawienie wyniku do otaczającego kontekstu\cite{scala3-reflection,epfl-dotty-reflection,scala3-guides-quotes}.

Formalna semantyka tych konstrukcji została przedstawiona w pracy Stuckiego, Brachthäusera i Odersky'ego\cite{stucki2021multistage}, gdzie quotes i splices są traktowane jako prymitywne formy w typowanych drzewach składni abstrakcyjnej (typed abstract syntax trees).
Autorzy dowodzą, że system zachowuje bezpieczeństwo typów oraz higieniczność, zapewniając, że wygenerowany kod nie może przypadkowo powiązać identyfikatorów z niewłaściwymi zmiennymi\cite{stucki2021multistage}.

\subsection{Bezpieczeństwo międzyetapowe}\label{subsec:bezpieczenstwo-miedzyetapowe}
Scala 3 gwarantuje bezpieczeństwo międzyetapowe (cross-stage safety) poprzez sprawdzanie poziomów etapowania w czasie kompilacji\cite{stucki2020thesis,stucki2021multistage}.
Zmienne lokalne mogą być używane tylko na tym samym poziomie etapowania, na którym zostały zdefiniowane, co zapobiega dostępowi do zmiennych, które jeszcze nie istnieją lub już nie są dostępne\cite{stucki2020thesis}.

System również zapewnia, że typy generyczne używane w wyższym poziomie etapowania niż ich definicja wymagają instancji klasy typu \verb|Type[T]|, która niesie reprezentację typu niepoddaną wymazywaniu (type erasure)\cite{stucki2020thesis}.
To podejście rozwiązuje problem wymazywania typów generycznych w~JVM, zachowując informację o typach potrzebną w kolejnych etapach kompilacji.


\section{Mechanizmy metaprogramowania w Scali 3}\label{sec:mechanizmy-metaprogramowania-w-scali-3}

\subsection{Definicje inline}\label{subsec:definicje-inline}
Najprostszym narzędziem metaprogramowania jest modyfikator \verb|inline|.
Gwarantuje on, że wywołanie oznaczonej nim metody lub wartości zostanie w całości \textbf{wstawione w miejscu wywołania} (ang. \textit{inlining}) podczas kompilacji. Jest to polecenie dla kompilatora, a nie tylko sugestia, jak w niektórych innych językach

\subsection{Makra oparte na wyrażeniach}\label{subsec:makra-oparte-na-wyrazeniach}
Makra w Scali 3 są zdefiniowane jako metody \verb|inline| zawierające splice najwyższego poziomu (top-level splice)\cite{scala3-reference-macros,scala3-guides-macros}, czyli taki, który nie jest zagnieżdżony w żadnym quotes i jest wykonywany w czasie kompilacji\cite{scala3-staging,scala3-reference-macros}.

Typ \texttt{Expr[T]} reprezentuje wyrażenie Scali o typie \texttt{T} jako typowane drzewo składni abstrakcyjnej\cite{scala3-reflection,scala3-guides-macros}.
Makra manipulują wartościami typu \texttt{Expr[T]}, transformując je lub generując nowe wyrażenia\cite{scala3-guides-macros}.
Ta reprezentacja gwarantuje bezpieczeństwo typów na poziomie języka metaprogramowania\cite{scala3-reflection}.

\subsection{Refleksja TASTy}\label{subsec:refleksja-tasty}
Dla przypadków wymagających głębszej analizy kodu, Scala 3 oferuje API refleksji TASTy (Typed Abstract Syntax Tree)\cite{scala3-reflection,epfl-dotty-reflection,scala3-guides-reflection}.
TASTy jest binarnym formatem serializacji typowanych drzew składni abstrakcyjnej używanym przez kompilator Scali 3\cite{stucki2020thesis}.

API refleksji dostarcza szczegółowy widok na strukturę kodu, włączając typy, symbole oraz pozycje w kodzie źródłowym\cite{scala3-reflection,scala3-guides-reflection}.
Jest dostępne poprzez obiekt \texttt{reflect} zdefiniowany w typie \texttt{Quotes}, który jest przekazywany kontekstualnie do makr\cite{scala3-reflection,scala3-guides-reflection}.


\section{Implementacja systemu metaprogramowania}\label{sec:implementacja-systemu-metaprogramowania}

\subsection{Architektura kompilatora}\label{subsec:architektura-kompilatora}
Implementacja systemu metaprogramowania w Scali 3 jest zorganizowana wokół kilku kluczowych komponentów\cite{stucki2020thesis}.
Proces kompilacji obejmuje fazę inliningu (\textit{Inlining} phase), która rozwija definicje \verb|inline| oraz wywołania makr\cite{dotty-compiler-phases}.

Faza \textit{PostInlining} wykonuje czyszczenie po rozwinięciu definicji inline, usuwając pomocnicze struktury i optymalizując kod\cite{dotty-compiler-phases}.
Faza \textit{Staging} zajmuje się sprawdzaniem poziomów etapowania oraz adaptacją typów etapowanych poprzez proces zwany ``type healing''\cite{stucki2020thesis,dotty-compiler-phases}.

\subsection{Dopasowanie wzorców w cytatach}\label{subsec:dopasowanie-wzorcow-w-cytatach}
Scala 3 wspiera analizę kodu poprzez dopasowanie wzorców w quotes (\textit{quote pattern matching})\cite{stucki2020thesis,stucki2021multistage}.
Mechanizm ten pozwala na dekonstrukcję kawałków kodu i ekstrakcję podwyrażeń\cite{stucki2021multistage}.

Stucki, Brachthäuser i Odersky\cite{stucki2021multistage} wprowadzają wzorce wiążące (\textit{bind patterns}) postaci \verb|$x| oraz wzorce HOAS (Higher-Order Abstract Syntax) postaci \verb|$f(y)|, które pozwalają na ekstrakcję podwyrażeń potencjalnie zawierających zmienne z zewnętrznego kontekstu\cite{stucki2021multistage}.
System gwarantuje, że ekstrahowane wyrażenia są zamknięte względem definicji wewnątrz wzorca, zapobiegając wyciekom zakresu\cite{stucki2021multistage}.


